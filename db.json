{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1}],"Cache":[{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1521999358000},{"_id":"source/.DS_Store","hash":"6974ddb0953597b845d10c3aec9016f9ed161fbb","modified":1522060779310},{"_id":"themes/apollo/_config.yml","hash":"4595ada444eef595a12f4b051a0204df103e7309","modified":1522142827240},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1521999358000},{"_id":"themes/apollo/README.md","hash":"201c76d030a98578ed5a6ad5c766a7bde91c32d3","modified":1521999358000},{"_id":"themes/apollo/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1521999358000},{"_id":"themes/apollo/package.json","hash":"eb1e76ec0b7ed6c6c7b2bd32b4f1e1bbe15800ca","modified":1521999358000},{"_id":"source/_posts/.DS_Store","hash":"6bf8b7e9176f20b7b9e33a412052ef2fadf17d3b","modified":1524808355587},{"_id":"source/_posts/KVC探索与实践.md","hash":"22b581adedb731d59d8ba8b7f8f97b579f55dd7f","modified":1522137240955},{"_id":"source/_posts/KVO探索与实践.md","hash":"421ed9eedfd40fccad5c63d372c68c0513167764","modified":1522137240958},{"_id":"source/_posts/探索iOS事件处理.md","hash":"cffc39d3af1b878d3cb0b6121ce57dc7937a8546","modified":1524810910655},{"_id":"source/_posts/字节序.md","hash":"40cdccb4917e52fc5a5bf387915793aefd18f8cc","modified":1522137240959},{"_id":"themes/apollo/doc/doc-zh.md","hash":"2a6a81840cdaf497969268a12d8f62c98cc38103","modified":1521999358000},{"_id":"themes/apollo/doc/doc-en.md","hash":"409e931a444c02a57b64a0a44dde6e66c1881ca0","modified":1521999358000},{"_id":"themes/apollo/languages/en.yml","hash":"ca168b190932229884db1de755ec2f793c758a16","modified":1521999358000},{"_id":"themes/apollo/languages/zh-cn.yml","hash":"22a2d16fe8c0dddb016b5325b9b9c182a1b49ae1","modified":1521999358000},{"_id":"themes/apollo/layout/archive.jade","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1521999358000},{"_id":"themes/apollo/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1521999358000},{"_id":"themes/apollo/layout/post.jade","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1521999358000},{"_id":"themes/apollo/source/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1521999358000},{"_id":"source/_posts/KVC探索与实践/1.jpg","hash":"1dd3e649aaa1951e114d93aa87f32b9d3f1378ef","modified":1522137240956},{"_id":"source/_posts/探索iOS事件处理/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1524811021430},{"_id":"source/_posts/探索iOS事件处理/2.png","hash":"6981ae3940f4f7d897386766af7e307eb5b47276","modified":1524810306555},{"_id":"themes/apollo/layout/mixins/post.jade","hash":"f23c6c40e14cdf16783b3c2baf736c9dce18408c","modified":1521999358000},{"_id":"themes/apollo/layout/mixins/paginator.jade","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1521999358000},{"_id":"themes/apollo/layout/partial/comment.jade","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1521999358000},{"_id":"themes/apollo/layout/partial/copyright.jade","hash":"217f8b17054e5079f2d30bb7e2e4e36c0f2161b7","modified":1521999358000},{"_id":"themes/apollo/layout/partial/head.jade","hash":"43d2db73f0247a9a3ed00ecb95b537a872b7201a","modified":1521999358000},{"_id":"themes/apollo/layout/partial/layout.jade","hash":"529c2ec06cfbc3d5b6d66dd320db50dfab5577a6","modified":1521999358000},{"_id":"themes/apollo/layout/partial/nav.jade","hash":"f4842d9d3d763fbb823d112a6f49f24cc42a0ad4","modified":1521999358000},{"_id":"themes/apollo/layout/partial/scripts.jade","hash":"6bff591ae3d1ff6750f239c4c933ad61f009f36a","modified":1521999358000},{"_id":"themes/apollo/source/css/apollo.css","hash":"e07a11a5da5fc097f023e06a85575356066afd09","modified":1521999358000},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1521999358000},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1521999358000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1521999358000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1521999358000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"ae967b2049ecb9b8c4e139ecce32fd9fb5358ac5","modified":1521999358000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1521999358000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1521999358000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1521999358000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1521999358000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"fc5dda52cfbb10e27e2471e03f4606fb3d588225","modified":1521999358000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1521999358000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"1998f207541a2590a5624549f96c5e65d136690a","modified":1521999358000},{"_id":"source/_posts/探索iOS事件处理/3.png","hash":"2ba27f8773332155eb3d7e2fde85ff47c8ea7e94","modified":1524809165334},{"_id":"public/sitemap.xml","hash":"191fbd45694f0d8ecf772ae4524cc37fa93f19dc","modified":1524811270492},{"_id":"public/atom.xml","hash":"faf3e99cca6f14a4c7d2853398c76e80e5ace7ef","modified":1524811270495},{"_id":"public/2017/06/27/探索iOS事件处理/index.html","hash":"a0602fb0d0a368fdf55f019e06924687e0106129","modified":1524811270498},{"_id":"public/2017/03/22/字节序/index.html","hash":"3213abce8a4872fa0a827e39c1623b4efd6f2846","modified":1524811270498},{"_id":"public/archives/index.html","hash":"b9cb1fea4970e1dfee0d6a3a14b986e4add704aa","modified":1524811270498},{"_id":"public/archives/2017/index.html","hash":"34dd1bfcc71efd3e416ae47d2002d3ed49926b5a","modified":1524811270498},{"_id":"public/archives/2017/03/index.html","hash":"75aa747c9cfb26e0c0eeb63c1b55a822b102a567","modified":1524811270498},{"_id":"public/archives/2017/04/index.html","hash":"68b4a0b03ba07b1d83f012eb08940ea1ae24266d","modified":1524811270498},{"_id":"public/archives/2017/05/index.html","hash":"b247a32f0e520ffd1e84115946d96de6aa50d191","modified":1524811270498},{"_id":"public/archives/2017/06/index.html","hash":"f0ce531722fa8a7c3d558c6c2e11f21f888a8e21","modified":1524811270499},{"_id":"public/index.html","hash":"7b1070b6a04315a5c0f5939bac37019d9105521f","modified":1524811270499},{"_id":"public/2017/05/23/KVC探索与实践/index.html","hash":"4dce4878610cd66d7a3432d02db88d2fba5b4a0c","modified":1524811270499},{"_id":"public/2017/04/12/KVO探索与实践/index.html","hash":"acce6404e78adef1541bb17de5ca19ce49ac7d83","modified":1524811270499},{"_id":"public/favicon.png","hash":"a9cdcb22d1e74d5480323e19d1983de5a6873b8c","modified":1524811270501},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1524811270501},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1524811270501},{"_id":"public/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1524811270501},{"_id":"public/2017/05/23/KVC探索与实践/1.jpg","hash":"1dd3e649aaa1951e114d93aa87f32b9d3f1378ef","modified":1524811270501},{"_id":"public/2017/06/27/探索iOS事件处理/2.png","hash":"6981ae3940f4f7d897386766af7e307eb5b47276","modified":1524811270501},{"_id":"public/css/apollo.css","hash":"e07a11a5da5fc097f023e06a85575356066afd09","modified":1524811270505},{"_id":"public/2017/06/27/探索iOS事件处理/3.png","hash":"2ba27f8773332155eb3d7e2fde85ff47c8ea7e94","modified":1524811270507}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"KVC探索与实践","date":"2017-05-23T09:41:56.000Z","_content":"# KVC探索与实践\n> KVC通过实现非正式协议`NSKeyValueCoding`，来实现间接访问和设置对象属性的一种机制。\n\n使用KVC你可以做到以下一些操作：\n\n<br>\n### KVC基础（Key-Value Coding Fundamental）\n\n-------\n\n#### 访问对象属性（Accessing Object Properties）\n* 获取值可以用以下方法:\n\n    ```objc\n    - (id)valueForKey:(NSString *)key;\n    - (id)valueForKeyPath:(NSString *)keyPath;\n    - (NSDictionary<NSString *, id> *)dictionaryWithValuesForKeys:(NSArray<NSString *> *)keys;\n    ```\n* 设置值用以下方法:\n\n ```objc\n- (void)setValue:(nullable id)value forKey:(NSString *)key;\n- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;\n- (void)setValuesForKeysWithDictionary:(NSDictionary<NSString *, id> *)keyedValues;\n```\n<br>\n\n<div class=\"tip\">\n**注意：**\n\t<div>1. 如果对象没有找到key，会抛出`NSUndefinedKeyException`,可以重写子类的`setValue:forUndefinedKey:`做一些自定义的逻辑判断。</div>\n\t<div>2. 如果设置值是nil，会抛出 `NSInvalidArgumentException`，`可以重写setNilValueForKey:`做一些自定义的逻辑判断。</div>\n</div>\n\n \n <br>\n### 访问集合属性\n返回的值是集合，key对应的属性可以使任何值。涉及的方法如下：\n\n**NSMutableArray**\n\n```objc\nmutableArrayValueForKey: \nmutableArrayValueForKeyPath:\n```\n**NSMutableSet**\n\n\n```objc\nmutableSetValueForKey:\nmutableSetValueForKeyPath:\n```\n\n**NSMutableOrderSet**\n\n```objc\nmutableOrderedSetValueForKey:\nmutableOrderedSetValueForKeyPath:\n```\n<br>\n### 使用集合操作符\n使用集合操作符，可以对集合属性进行一下计算操作，比如计算平均值，总数等。使用的时候有两种方式\n\n```objc\n// Employee.h\n@property (nonatomic, assign) NSInteger age;\n\n// Department.h\n@property (nonatomic, strong) NSArray<Employee *> *allEmployees;\n\n// client.m\nDepartment *depart = [Department new];\n \n// 第一种方式\nNSNumber *number = [depart.allEmployees valueForKeyPath:@\"@sum.age\"];\n\n// 第二种方式\nNSNumber *number = [depart valueForKeyPath:@\"allEmployees.@sum.age\"];\n```\n\n在KVC中使用操作符的格式如下(@count除外)：\n\n![](KVC探索与实践/1.jpg)\n\n* 左路径 (left key path):指向是集合类型的属性\n* 操作符 (colletion operator): 以'@'开始\n* 右路径 (right key path):\n\n\n**操作符的种类：**\n\n1. **聚合操作符（Aggregation Operators）：**返回单个值，比如`@count`、`@avg`、`@max`、`@min`、`@sum`\n2. **数组操作符（Array Operators）：**返回值是数组，比如`@distinctUnionOfObjects`、`@unionOfObjects`，两者区别是@distinctUnionOfObjects没有重复值\n3. **嵌入操作符（Nesting Operators）：**返回值是NSArray或者NSSet,比如`@distinctUnionOfArrays`、`@unionOfArrays`、`@distinctUnionOfSets`。实例：\n\n    ```\n    NSArray *arrayOne = @[.....];\n    NSArray *arrayOther = @[.....];\n    NSArray *concactArray = @[arrayOne, arrayOther];\n    \n    NSArray *collectedDistinctPayees = [concactArray valueForKeyPath:@\"@distinctUnionOfArrays.payee\"];\n```\n\n<br>\n### 非对象的数据\n基本的数据类型如`int`、`float`等，需要转换成`NSNumber`类型，`struct`需要转换成`NSValue`类型（针对Objective-C）\n\n<br>\n### 键值验证（Validating Properties）\nKVC提供了可以检测设置的值的类型是否符合属性类型的要求的方法：\n\n```\n- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;\n- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;\n```\n子类可以根据自己的校验逻辑重写这个方法。\n\n<br>\n### KVC设值和取值的流程\n\n<br>\n##### 通过Getter获取值\n当调用方法`valueForKey:`时，按照以下流程处理：\n\n1. 按照`get<Key>`, `<key>`, `is<Key>`, `_<key>`的顺序寻找方法，如果寻找到了，跳转到步骤5，否则进行步骤2。\n2. 如果对象实现了`countOf<Key>`，同时实现了 `objectIn<Key>AtIndex:`，`<key>AtIndexes:` 其中的一个。对于方法 `get<Key>:range:`的是实现是**可选**的。如果实现了，那么就会生成一个集合代理对象（其实就是一个`NSMutatableArray`的子类`NSKeyValueMutableArray`），这个`集合代理对象`和`NSArray`的操作没什么区别。并返回这个集合代理对象。否则，进行步骤3。\n3. 如果对象同时实现了`countOf<Key>`, `enumeratorOf<Key>,` and `memberOf<Key>:`那么就会生成一个集合代理对象（其实就是一个`NSSet`的子类`NSKeyValueSet`），这个`集合代理对象`和`NSSet`的操作没什么区别。并返回这个集合代理对象。否则，进行步骤4。\n4. 查看对象的类方法 `accessInstanceVariablesDirectly` 返回的值是`YES`,那么按照顺序寻找实例变量` _<key>`, `_is<Key>`, `<key>`, 或者`is<Key>`,然后直接获取值，进行步骤5。否则进行步骤6。\n5. 如果是`对象类型`，直接返回，如果是`int`、`struct`等数据类型封装成`NSNumber`或者`NSValue`。\n6. 触发`valueForUndefinedKey`:方法，抛出异常。\n\n<br>\n##### 通过Setter设值\n当调用方法`setValue:forKey:`时，按照以下流程处理：\n\n1. 安装顺序寻找方法 `set<Key>:` ， `_set<Key>`，如果找到了把输入的值当做参数传入其中。\n2. 查看对象的类方法 `accessInstanceVariablesDirectly` 返回的值是`YES`,那么按照顺序寻找实例变量` _<key>`, `_is<Key>`, `<key>`, 或者`is<Key>`,然后直接获赋值。\n3. 触发`valueForUndefinedKey`:方法，抛出异常。\n\n<br>\n##### 返回可变数组/Mutable Ordered Sets\n当调用方法` mutableArrayValueForKey:`或者` mutableOrderedSetValueForKey: `时，按照以下流程处理：\n\n1. 判断是否实现以下方法\n\n    ```objc\n    // 这两个方法和 NSMutableArray/NSMutableOrderedSet 的方法 insertObject:atIndex: 和 removeObjectAtIndex: 对应\n    insertObject:in<Key>AtIndex:\n    removeObjectFrom<Key>AtIndex:\n    \n    // 这两个方法和 NSMutableArray/NSMutableOrderedSet 的方法 insertObjects:atIndexes: 和 removeObjectsAtIndexes: 对应\n    insert<Key>:atIndexes: \n    remove<Key>AtIndexes:\n    ```\n      中的一个**插入**和**移除**方法。如果实现了，那么就返回一个代理对象。否则进行步骤2。而对于方法\n        \n    ```objc\nreplaceObjectIn<Key>AtIndex:withObject: \n    //或者\nreplace<Key>AtIndexes:with<Key>:\n    ```\n    可以增强效果。\n2. 寻找 `set<Key>:`方法。\n3. 如果`array / mtuableOrderSet`的方法和 `set<Key>:`都没有寻找到。查看对象的类方法 `accessInstanceVariablesDirectly` 返回的值是`YES`,那么按照顺序寻找实例变量` _<key>`, `<key>`,如果找到了，会生成一个代理对象，这个对象会把NSMutableArray的方法发送给这个实例变量。\n4.  触发`valueForUndefinedKey`:方法，抛出异常。\n\n\n<br>\n##### 返回mutableSet\n当调用方法`mutableSetValueForKey:`时，按照以下流程处理：\n\n1. 判断是否实现以下方法\n\n    ```objc\n    // 这两个方法和  NSMutableSet 的方法  addObject: 和  removeObject: 对应\n    add<Key>Object:\n    remove<Key>Object:\n     \n    // 这两个方法和  NSMutableSet 的方法  unionSet: 和  minusSet: 对应\n    add<Key>:\n    remove<Key>: \n    ```\n    中的一个**添加**和**移除**方法。如果实现了，那么就返回一个代理对象。否则进行步骤2。而对于方法\n \n    ```objc\n    intersect<Key>:\n    set<Key>:\n    ```\n\t可以增强效果。\n\n2. 如果响应 `mutableSetValueForKey:`的对象是一个`managed object`（像` CoreData的Managed Object`）,查询将停止。\n3. 寻找 `set<Key>:`方法。\n4. 如果`array / mtuableOrderSet`的方法和 `set<Key>:`都没有寻找到。查看对象的类方法 `accessInstanceVariablesDirectly` 返回的值是`YES`,那么按照顺序寻找实例变量` _<key>`, `<key>`,如果找到了，会生成一个代理对象，这个对象会把NSMutableArray的方法发送给这个实例变量。\n5.  触发`valueForUndefinedKey`:方法，抛出异常。\n\n<br>\n参考资料：\n \n * [Key-Value Coding Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA)\n\n","source":"_posts/KVC探索与实践.md","raw":"---\ntitle: KVC探索与实践\ndate: 2017-05-23 17:41:56\n---\n# KVC探索与实践\n> KVC通过实现非正式协议`NSKeyValueCoding`，来实现间接访问和设置对象属性的一种机制。\n\n使用KVC你可以做到以下一些操作：\n\n<br>\n### KVC基础（Key-Value Coding Fundamental）\n\n-------\n\n#### 访问对象属性（Accessing Object Properties）\n* 获取值可以用以下方法:\n\n    ```objc\n    - (id)valueForKey:(NSString *)key;\n    - (id)valueForKeyPath:(NSString *)keyPath;\n    - (NSDictionary<NSString *, id> *)dictionaryWithValuesForKeys:(NSArray<NSString *> *)keys;\n    ```\n* 设置值用以下方法:\n\n ```objc\n- (void)setValue:(nullable id)value forKey:(NSString *)key;\n- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;\n- (void)setValuesForKeysWithDictionary:(NSDictionary<NSString *, id> *)keyedValues;\n```\n<br>\n\n<div class=\"tip\">\n**注意：**\n\t<div>1. 如果对象没有找到key，会抛出`NSUndefinedKeyException`,可以重写子类的`setValue:forUndefinedKey:`做一些自定义的逻辑判断。</div>\n\t<div>2. 如果设置值是nil，会抛出 `NSInvalidArgumentException`，`可以重写setNilValueForKey:`做一些自定义的逻辑判断。</div>\n</div>\n\n \n <br>\n### 访问集合属性\n返回的值是集合，key对应的属性可以使任何值。涉及的方法如下：\n\n**NSMutableArray**\n\n```objc\nmutableArrayValueForKey: \nmutableArrayValueForKeyPath:\n```\n**NSMutableSet**\n\n\n```objc\nmutableSetValueForKey:\nmutableSetValueForKeyPath:\n```\n\n**NSMutableOrderSet**\n\n```objc\nmutableOrderedSetValueForKey:\nmutableOrderedSetValueForKeyPath:\n```\n<br>\n### 使用集合操作符\n使用集合操作符，可以对集合属性进行一下计算操作，比如计算平均值，总数等。使用的时候有两种方式\n\n```objc\n// Employee.h\n@property (nonatomic, assign) NSInteger age;\n\n// Department.h\n@property (nonatomic, strong) NSArray<Employee *> *allEmployees;\n\n// client.m\nDepartment *depart = [Department new];\n \n// 第一种方式\nNSNumber *number = [depart.allEmployees valueForKeyPath:@\"@sum.age\"];\n\n// 第二种方式\nNSNumber *number = [depart valueForKeyPath:@\"allEmployees.@sum.age\"];\n```\n\n在KVC中使用操作符的格式如下(@count除外)：\n\n![](KVC探索与实践/1.jpg)\n\n* 左路径 (left key path):指向是集合类型的属性\n* 操作符 (colletion operator): 以'@'开始\n* 右路径 (right key path):\n\n\n**操作符的种类：**\n\n1. **聚合操作符（Aggregation Operators）：**返回单个值，比如`@count`、`@avg`、`@max`、`@min`、`@sum`\n2. **数组操作符（Array Operators）：**返回值是数组，比如`@distinctUnionOfObjects`、`@unionOfObjects`，两者区别是@distinctUnionOfObjects没有重复值\n3. **嵌入操作符（Nesting Operators）：**返回值是NSArray或者NSSet,比如`@distinctUnionOfArrays`、`@unionOfArrays`、`@distinctUnionOfSets`。实例：\n\n    ```\n    NSArray *arrayOne = @[.....];\n    NSArray *arrayOther = @[.....];\n    NSArray *concactArray = @[arrayOne, arrayOther];\n    \n    NSArray *collectedDistinctPayees = [concactArray valueForKeyPath:@\"@distinctUnionOfArrays.payee\"];\n```\n\n<br>\n### 非对象的数据\n基本的数据类型如`int`、`float`等，需要转换成`NSNumber`类型，`struct`需要转换成`NSValue`类型（针对Objective-C）\n\n<br>\n### 键值验证（Validating Properties）\nKVC提供了可以检测设置的值的类型是否符合属性类型的要求的方法：\n\n```\n- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;\n- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;\n```\n子类可以根据自己的校验逻辑重写这个方法。\n\n<br>\n### KVC设值和取值的流程\n\n<br>\n##### 通过Getter获取值\n当调用方法`valueForKey:`时，按照以下流程处理：\n\n1. 按照`get<Key>`, `<key>`, `is<Key>`, `_<key>`的顺序寻找方法，如果寻找到了，跳转到步骤5，否则进行步骤2。\n2. 如果对象实现了`countOf<Key>`，同时实现了 `objectIn<Key>AtIndex:`，`<key>AtIndexes:` 其中的一个。对于方法 `get<Key>:range:`的是实现是**可选**的。如果实现了，那么就会生成一个集合代理对象（其实就是一个`NSMutatableArray`的子类`NSKeyValueMutableArray`），这个`集合代理对象`和`NSArray`的操作没什么区别。并返回这个集合代理对象。否则，进行步骤3。\n3. 如果对象同时实现了`countOf<Key>`, `enumeratorOf<Key>,` and `memberOf<Key>:`那么就会生成一个集合代理对象（其实就是一个`NSSet`的子类`NSKeyValueSet`），这个`集合代理对象`和`NSSet`的操作没什么区别。并返回这个集合代理对象。否则，进行步骤4。\n4. 查看对象的类方法 `accessInstanceVariablesDirectly` 返回的值是`YES`,那么按照顺序寻找实例变量` _<key>`, `_is<Key>`, `<key>`, 或者`is<Key>`,然后直接获取值，进行步骤5。否则进行步骤6。\n5. 如果是`对象类型`，直接返回，如果是`int`、`struct`等数据类型封装成`NSNumber`或者`NSValue`。\n6. 触发`valueForUndefinedKey`:方法，抛出异常。\n\n<br>\n##### 通过Setter设值\n当调用方法`setValue:forKey:`时，按照以下流程处理：\n\n1. 安装顺序寻找方法 `set<Key>:` ， `_set<Key>`，如果找到了把输入的值当做参数传入其中。\n2. 查看对象的类方法 `accessInstanceVariablesDirectly` 返回的值是`YES`,那么按照顺序寻找实例变量` _<key>`, `_is<Key>`, `<key>`, 或者`is<Key>`,然后直接获赋值。\n3. 触发`valueForUndefinedKey`:方法，抛出异常。\n\n<br>\n##### 返回可变数组/Mutable Ordered Sets\n当调用方法` mutableArrayValueForKey:`或者` mutableOrderedSetValueForKey: `时，按照以下流程处理：\n\n1. 判断是否实现以下方法\n\n    ```objc\n    // 这两个方法和 NSMutableArray/NSMutableOrderedSet 的方法 insertObject:atIndex: 和 removeObjectAtIndex: 对应\n    insertObject:in<Key>AtIndex:\n    removeObjectFrom<Key>AtIndex:\n    \n    // 这两个方法和 NSMutableArray/NSMutableOrderedSet 的方法 insertObjects:atIndexes: 和 removeObjectsAtIndexes: 对应\n    insert<Key>:atIndexes: \n    remove<Key>AtIndexes:\n    ```\n      中的一个**插入**和**移除**方法。如果实现了，那么就返回一个代理对象。否则进行步骤2。而对于方法\n        \n    ```objc\nreplaceObjectIn<Key>AtIndex:withObject: \n    //或者\nreplace<Key>AtIndexes:with<Key>:\n    ```\n    可以增强效果。\n2. 寻找 `set<Key>:`方法。\n3. 如果`array / mtuableOrderSet`的方法和 `set<Key>:`都没有寻找到。查看对象的类方法 `accessInstanceVariablesDirectly` 返回的值是`YES`,那么按照顺序寻找实例变量` _<key>`, `<key>`,如果找到了，会生成一个代理对象，这个对象会把NSMutableArray的方法发送给这个实例变量。\n4.  触发`valueForUndefinedKey`:方法，抛出异常。\n\n\n<br>\n##### 返回mutableSet\n当调用方法`mutableSetValueForKey:`时，按照以下流程处理：\n\n1. 判断是否实现以下方法\n\n    ```objc\n    // 这两个方法和  NSMutableSet 的方法  addObject: 和  removeObject: 对应\n    add<Key>Object:\n    remove<Key>Object:\n     \n    // 这两个方法和  NSMutableSet 的方法  unionSet: 和  minusSet: 对应\n    add<Key>:\n    remove<Key>: \n    ```\n    中的一个**添加**和**移除**方法。如果实现了，那么就返回一个代理对象。否则进行步骤2。而对于方法\n \n    ```objc\n    intersect<Key>:\n    set<Key>:\n    ```\n\t可以增强效果。\n\n2. 如果响应 `mutableSetValueForKey:`的对象是一个`managed object`（像` CoreData的Managed Object`）,查询将停止。\n3. 寻找 `set<Key>:`方法。\n4. 如果`array / mtuableOrderSet`的方法和 `set<Key>:`都没有寻找到。查看对象的类方法 `accessInstanceVariablesDirectly` 返回的值是`YES`,那么按照顺序寻找实例变量` _<key>`, `<key>`,如果找到了，会生成一个代理对象，这个对象会把NSMutableArray的方法发送给这个实例变量。\n5.  触发`valueForUndefinedKey`:方法，抛出异常。\n\n<br>\n参考资料：\n \n * [Key-Value Coding Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA)\n\n","slug":"KVC探索与实践","published":1,"updated":"2018-03-27T07:54:00.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjghl49fq0000pnqkivngw7w1","content":"<h1 id=\"KVC探索与实践\"><a href=\"#KVC探索与实践\" class=\"headerlink\" title=\"KVC探索与实践\"></a>KVC探索与实践</h1><blockquote>\n<p>KVC通过实现非正式协议<code>NSKeyValueCoding</code>，来实现间接访问和设置对象属性的一种机制。</p>\n</blockquote>\n<p>使用KVC你可以做到以下一些操作：</p>\n<p><br></p>\n<h3 id=\"KVC基础（Key-Value-Coding-Fundamental）\"><a href=\"#KVC基础（Key-Value-Coding-Fundamental）\" class=\"headerlink\" title=\"KVC基础（Key-Value Coding Fundamental）\"></a>KVC基础（Key-Value Coding Fundamental）</h3><hr>\n<h4 id=\"访问对象属性（Accessing-Object-Properties）\"><a href=\"#访问对象属性（Accessing-Object-Properties）\" class=\"headerlink\" title=\"访问对象属性（Accessing Object Properties）\"></a>访问对象属性（Accessing Object Properties）</h4><ul>\n<li><p>获取值可以用以下方法:</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)valueForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)valueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;</span><br><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"keyword\">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置值用以下方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setValuesForKeysWithDictionary:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"keyword\">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<div class=\"tip\"><br><strong>注意：</strong><br>    <div>1. 如果对象没有找到key，会抛出<code>NSUndefinedKeyException</code>,可以重写子类的<code>setValue:forUndefinedKey:</code>做一些自定义的逻辑判断。</div><br>    <div>2. 如果设置值是nil，会抛出 <code>NSInvalidArgumentException</code>，<code>可以重写setNilValueForKey:</code>做一些自定义的逻辑判断。</div><br></div>\n\n\n<p> <br></p>\n<h3 id=\"访问集合属性\"><a href=\"#访问集合属性\" class=\"headerlink\" title=\"访问集合属性\"></a>访问集合属性</h3><p>返回的值是集合，key对应的属性可以使任何值。涉及的方法如下：</p>\n<p><strong>NSMutableArray</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableArrayValueForKey: </span><br><span class=\"line\">mutableArrayValueForKeyPath:</span><br></pre></td></tr></table></figure>\n<p><strong>NSMutableSet</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableSetValueForKey:</span><br><span class=\"line\">mutableSetValueForKeyPath:</span><br></pre></td></tr></table></figure>\n<p><strong>NSMutableOrderSet</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableOrderedSetValueForKey:</span><br><span class=\"line\">mutableOrderedSetValueForKeyPath:</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"使用集合操作符\"><a href=\"#使用集合操作符\" class=\"headerlink\" title=\"使用集合操作符\"></a>使用集合操作符</h3><p>使用集合操作符，可以对集合属性进行一下计算操作，比如计算平均值，总数等。使用的时候有两种方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Employee.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Department.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span>&lt;Employee *&gt; *allEmployees;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// client.m</span></span><br><span class=\"line\">Department *depart = [Department new];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 第一种方式</span></span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number = [depart.allEmployees valueForKeyPath:<span class=\"string\">@\"@sum.age\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种方式</span></span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number = [depart valueForKeyPath:<span class=\"string\">@\"allEmployees.@sum.age\"</span>];</span><br></pre></td></tr></table></figure>\n<p>在KVC中使用操作符的格式如下(@count除外)：</p>\n<p><img src=\"/2017/05/23/KVC探索与实践/1.jpg\" alt=\"\"></p>\n<ul>\n<li>左路径 (left key path):指向是集合类型的属性</li>\n<li>操作符 (colletion operator): 以‘@’开始</li>\n<li>右路径 (right key path):</li>\n</ul>\n<p><strong>操作符的种类：</strong></p>\n<ol>\n<li><strong>聚合操作符（Aggregation Operators）：</strong>返回单个值，比如<code>@count</code>、<code>@avg</code>、<code>@max</code>、<code>@min</code>、<code>@sum</code></li>\n<li><strong>数组操作符（Array Operators）：</strong>返回值是数组，比如<code>@distinctUnionOfObjects</code>、<code>@unionOfObjects</code>，两者区别是@distinctUnionOfObjects没有重复值</li>\n<li><p><strong>嵌入操作符（Nesting Operators）：</strong>返回值是NSArray或者NSSet,比如<code>@distinctUnionOfArrays</code>、<code>@unionOfArrays</code>、<code>@distinctUnionOfSets</code>。实例：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSArray *arrayOne = @[.....];</span><br><span class=\"line\">NSArray *arrayOther = @[.....];</span><br><span class=\"line\">NSArray *concactArray = @[arrayOne, arrayOther];</span><br><span class=\"line\"></span><br><span class=\"line\">NSArray *collectedDistinctPayees = [concactArray valueForKeyPath:@&quot;@distinctUnionOfArrays.payee&quot;];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><br></p>\n<h3 id=\"非对象的数据\"><a href=\"#非对象的数据\" class=\"headerlink\" title=\"非对象的数据\"></a>非对象的数据</h3><p>基本的数据类型如<code>int</code>、<code>float</code>等，需要转换成<code>NSNumber</code>类型，<code>struct</code>需要转换成<code>NSValue</code>类型（针对Objective-C）</p>\n<p><br></p>\n<h3 id=\"键值验证（Validating-Properties）\"><a href=\"#键值验证（Validating-Properties）\" class=\"headerlink\" title=\"键值验证（Validating Properties）\"></a>键值验证（Validating Properties）</h3><p>KVC提供了可以检测设置的值的类型是否符合属性类型的要求的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br><span class=\"line\">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;</span><br></pre></td></tr></table></figure>\n<p>子类可以根据自己的校验逻辑重写这个方法。</p>\n<p><br></p>\n<h3 id=\"KVC设值和取值的流程\"><a href=\"#KVC设值和取值的流程\" class=\"headerlink\" title=\"KVC设值和取值的流程\"></a>KVC设值和取值的流程</h3><p><br></p>\n<h5 id=\"通过Getter获取值\"><a href=\"#通过Getter获取值\" class=\"headerlink\" title=\"通过Getter获取值\"></a>通过Getter获取值</h5><p>当调用方法<code>valueForKey:</code>时，按照以下流程处理：</p>\n<ol>\n<li>按照<code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>, <code>_&lt;key&gt;</code>的顺序寻找方法，如果寻找到了，跳转到步骤5，否则进行步骤2。</li>\n<li>如果对象实现了<code>countOf&lt;Key&gt;</code>，同时实现了 <code>objectIn&lt;Key&gt;AtIndex:</code>，<code>&lt;key&gt;AtIndexes:</code> 其中的一个。对于方法 <code>get&lt;Key&gt;:range:</code>的是实现是<strong>可选</strong>的。如果实现了，那么就会生成一个集合代理对象（其实就是一个<code>NSMutatableArray</code>的子类<code>NSKeyValueMutableArray</code>），这个<code>集合代理对象</code>和<code>NSArray</code>的操作没什么区别。并返回这个集合代理对象。否则，进行步骤3。</li>\n<li>如果对象同时实现了<code>countOf&lt;Key&gt;</code>, <code>enumeratorOf&lt;Key&gt;,</code> and <code>memberOf&lt;Key&gt;:</code>那么就会生成一个集合代理对象（其实就是一个<code>NSSet</code>的子类<code>NSKeyValueSet</code>），这个<code>集合代理对象</code>和<code>NSSet</code>的操作没什么区别。并返回这个集合代理对象。否则，进行步骤4。</li>\n<li>查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, 或者<code>is&lt;Key&gt;</code>,然后直接获取值，进行步骤5。否则进行步骤6。</li>\n<li>如果是<code>对象类型</code>，直接返回，如果是<code>int</code>、<code>struct</code>等数据类型封装成<code>NSNumber</code>或者<code>NSValue</code>。</li>\n<li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li>\n</ol>\n<p><br></p>\n<h5 id=\"通过Setter设值\"><a href=\"#通过Setter设值\" class=\"headerlink\" title=\"通过Setter设值\"></a>通过Setter设值</h5><p>当调用方法<code>setValue:forKey:</code>时，按照以下流程处理：</p>\n<ol>\n<li>安装顺序寻找方法 <code>set&lt;Key&gt;:</code> ， <code>_set&lt;Key&gt;</code>，如果找到了把输入的值当做参数传入其中。</li>\n<li>查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, 或者<code>is&lt;Key&gt;</code>,然后直接获赋值。</li>\n<li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li>\n</ol>\n<p><br></p>\n<h5 id=\"返回可变数组-Mutable-Ordered-Sets\"><a href=\"#返回可变数组-Mutable-Ordered-Sets\" class=\"headerlink\" title=\"返回可变数组/Mutable Ordered Sets\"></a>返回可变数组/Mutable Ordered Sets</h5><p>当调用方法<code>mutableArrayValueForKey:</code>或者<code>mutableOrderedSetValueForKey:</code>时，按照以下流程处理：</p>\n<ol>\n<li><p>判断是否实现以下方法</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这两个方法和 NSMutableArray/NSMutableOrderedSet 的方法 insertObject:atIndex: 和 removeObjectAtIndex: 对应</span></span><br><span class=\"line\">insertObject:<span class=\"keyword\">in</span>&lt;Key&gt;AtIndex:</span><br><span class=\"line\">removeObjectFrom&lt;Key&gt;AtIndex:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这两个方法和 NSMutableArray/NSMutableOrderedSet 的方法 insertObjects:atIndexes: 和 removeObjectsAtIndexes: 对应</span></span><br><span class=\"line\">insert&lt;Key&gt;:atIndexes: </span><br><span class=\"line\">remove&lt;Key&gt;AtIndexes:</span><br></pre></td></tr></table></figure>\n<p>   中的一个<strong>插入</strong>和<strong>移除</strong>方法。如果实现了，那么就返回一个代理对象。否则进行步骤2。而对于方法</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">replaceObjectIn&lt;Key&gt;AtIndex:withObject: </span><br><span class=\"line\">    <span class=\"comment\">//或者</span></span><br><span class=\"line\">replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</span><br></pre></td></tr></table></figure>\n<p> 可以增强效果。</p>\n</li>\n<li>寻找 <code>set&lt;Key&gt;:</code>方法。</li>\n<li>如果<code>array / mtuableOrderSet</code>的方法和 <code>set&lt;Key&gt;:</code>都没有寻找到。查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>&lt;key&gt;</code>,如果找到了，会生成一个代理对象，这个对象会把NSMutableArray的方法发送给这个实例变量。</li>\n<li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li>\n</ol>\n<p><br></p>\n<h5 id=\"返回mutableSet\"><a href=\"#返回mutableSet\" class=\"headerlink\" title=\"返回mutableSet\"></a>返回mutableSet</h5><p>当调用方法<code>mutableSetValueForKey:</code>时，按照以下流程处理：</p>\n<ol>\n<li><p>判断是否实现以下方法</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这两个方法和  NSMutableSet 的方法  addObject: 和  removeObject: 对应</span></span><br><span class=\"line\">add&lt;Key&gt;Object:</span><br><span class=\"line\">remove&lt;Key&gt;Object:</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 这两个方法和  NSMutableSet 的方法  unionSet: 和  minusSet: 对应</span></span><br><span class=\"line\">add&lt;Key&gt;:</span><br><span class=\"line\">remove&lt;Key&gt;:</span><br></pre></td></tr></table></figure>\n<p> 中的一个<strong>添加</strong>和<strong>移除</strong>方法。如果实现了，那么就返回一个代理对象。否则进行步骤2。而对于方法</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intersect&lt;Key&gt;:</span><br><span class=\"line\">set&lt;Key&gt;:</span><br></pre></td></tr></table></figure>\n<p> 可以增强效果。</p>\n</li>\n<li><p>如果响应 <code>mutableSetValueForKey:</code>的对象是一个<code>managed object</code>（像<code>CoreData的Managed Object</code>）,查询将停止。</p>\n</li>\n<li>寻找 <code>set&lt;Key&gt;:</code>方法。</li>\n<li>如果<code>array / mtuableOrderSet</code>的方法和 <code>set&lt;Key&gt;:</code>都没有寻找到。查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>&lt;key&gt;</code>,如果找到了，会生成一个代理对象，这个对象会把NSMutableArray的方法发送给这个实例变量。</li>\n<li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li>\n</ol>\n<p><br><br>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA\" target=\"_blank\" rel=\"noopener\">Key-Value Coding Programming Guide</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"KVC探索与实践\"><a href=\"#KVC探索与实践\" class=\"headerlink\" title=\"KVC探索与实践\"></a>KVC探索与实践</h1><blockquote>\n<p>KVC通过实现非正式协议<code>NSKeyValueCoding</code>，来实现间接访问和设置对象属性的一种机制。</p>\n</blockquote>\n<p>使用KVC你可以做到以下一些操作：</p>\n<p><br></p>\n<h3 id=\"KVC基础（Key-Value-Coding-Fundamental）\"><a href=\"#KVC基础（Key-Value-Coding-Fundamental）\" class=\"headerlink\" title=\"KVC基础（Key-Value Coding Fundamental）\"></a>KVC基础（Key-Value Coding Fundamental）</h3><hr>\n<h4 id=\"访问对象属性（Accessing-Object-Properties）\"><a href=\"#访问对象属性（Accessing-Object-Properties）\" class=\"headerlink\" title=\"访问对象属性（Accessing Object Properties）\"></a>访问对象属性（Accessing Object Properties）</h4><ul>\n<li><p>获取值可以用以下方法:</p>\n  <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)valueForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">- (<span class=\"keyword\">id</span>)valueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;</span><br><span class=\"line\">- (<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"keyword\">id</span>&gt; *)dictionaryWithValuesForKeys:(<span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置值用以下方法:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)key;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setValue:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)value forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setValuesForKeysWithDictionary:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSString</span> *, <span class=\"keyword\">id</span>&gt; *)keyedValues;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<div class=\"tip\"><br><strong>注意：</strong><br>    <div>1. 如果对象没有找到key，会抛出<code>NSUndefinedKeyException</code>,可以重写子类的<code>setValue:forUndefinedKey:</code>做一些自定义的逻辑判断。</div><br>    <div>2. 如果设置值是nil，会抛出 <code>NSInvalidArgumentException</code>，<code>可以重写setNilValueForKey:</code>做一些自定义的逻辑判断。</div><br></div>\n\n\n<p> <br></p>\n<h3 id=\"访问集合属性\"><a href=\"#访问集合属性\" class=\"headerlink\" title=\"访问集合属性\"></a>访问集合属性</h3><p>返回的值是集合，key对应的属性可以使任何值。涉及的方法如下：</p>\n<p><strong>NSMutableArray</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableArrayValueForKey: </span><br><span class=\"line\">mutableArrayValueForKeyPath:</span><br></pre></td></tr></table></figure>\n<p><strong>NSMutableSet</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableSetValueForKey:</span><br><span class=\"line\">mutableSetValueForKeyPath:</span><br></pre></td></tr></table></figure>\n<p><strong>NSMutableOrderSet</strong></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutableOrderedSetValueForKey:</span><br><span class=\"line\">mutableOrderedSetValueForKeyPath:</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"使用集合操作符\"><a href=\"#使用集合操作符\" class=\"headerlink\" title=\"使用集合操作符\"></a>使用集合操作符</h3><p>使用集合操作符，可以对集合属性进行一下计算操作，比如计算平均值，总数等。使用的时候有两种方式</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Employee.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Department.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span>&lt;Employee *&gt; *allEmployees;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// client.m</span></span><br><span class=\"line\">Department *depart = [Department new];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 第一种方式</span></span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number = [depart.allEmployees valueForKeyPath:<span class=\"string\">@\"@sum.age\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种方式</span></span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number = [depart valueForKeyPath:<span class=\"string\">@\"allEmployees.@sum.age\"</span>];</span><br></pre></td></tr></table></figure>\n<p>在KVC中使用操作符的格式如下(@count除外)：</p>\n<p><img src=\"/2017/05/23/KVC探索与实践/1.jpg\" alt=\"\"></p>\n<ul>\n<li>左路径 (left key path):指向是集合类型的属性</li>\n<li>操作符 (colletion operator): 以‘@’开始</li>\n<li>右路径 (right key path):</li>\n</ul>\n<p><strong>操作符的种类：</strong></p>\n<ol>\n<li><strong>聚合操作符（Aggregation Operators）：</strong>返回单个值，比如<code>@count</code>、<code>@avg</code>、<code>@max</code>、<code>@min</code>、<code>@sum</code></li>\n<li><strong>数组操作符（Array Operators）：</strong>返回值是数组，比如<code>@distinctUnionOfObjects</code>、<code>@unionOfObjects</code>，两者区别是@distinctUnionOfObjects没有重复值</li>\n<li><p><strong>嵌入操作符（Nesting Operators）：</strong>返回值是NSArray或者NSSet,比如<code>@distinctUnionOfArrays</code>、<code>@unionOfArrays</code>、<code>@distinctUnionOfSets</code>。实例：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSArray *arrayOne = @[.....];</span><br><span class=\"line\">NSArray *arrayOther = @[.....];</span><br><span class=\"line\">NSArray *concactArray = @[arrayOne, arrayOther];</span><br><span class=\"line\"></span><br><span class=\"line\">NSArray *collectedDistinctPayees = [concactArray valueForKeyPath:@&quot;@distinctUnionOfArrays.payee&quot;];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><br></p>\n<h3 id=\"非对象的数据\"><a href=\"#非对象的数据\" class=\"headerlink\" title=\"非对象的数据\"></a>非对象的数据</h3><p>基本的数据类型如<code>int</code>、<code>float</code>等，需要转换成<code>NSNumber</code>类型，<code>struct</code>需要转换成<code>NSValue</code>类型（针对Objective-C）</p>\n<p><br></p>\n<h3 id=\"键值验证（Validating-Properties）\"><a href=\"#键值验证（Validating-Properties）\" class=\"headerlink\" title=\"键值验证（Validating Properties）\"></a>键值验证（Validating Properties）</h3><p>KVC提供了可以检测设置的值的类型是否符合属性类型的要求的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br><span class=\"line\">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;</span><br></pre></td></tr></table></figure>\n<p>子类可以根据自己的校验逻辑重写这个方法。</p>\n<p><br></p>\n<h3 id=\"KVC设值和取值的流程\"><a href=\"#KVC设值和取值的流程\" class=\"headerlink\" title=\"KVC设值和取值的流程\"></a>KVC设值和取值的流程</h3><p><br></p>\n<h5 id=\"通过Getter获取值\"><a href=\"#通过Getter获取值\" class=\"headerlink\" title=\"通过Getter获取值\"></a>通过Getter获取值</h5><p>当调用方法<code>valueForKey:</code>时，按照以下流程处理：</p>\n<ol>\n<li>按照<code>get&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, <code>is&lt;Key&gt;</code>, <code>_&lt;key&gt;</code>的顺序寻找方法，如果寻找到了，跳转到步骤5，否则进行步骤2。</li>\n<li>如果对象实现了<code>countOf&lt;Key&gt;</code>，同时实现了 <code>objectIn&lt;Key&gt;AtIndex:</code>，<code>&lt;key&gt;AtIndexes:</code> 其中的一个。对于方法 <code>get&lt;Key&gt;:range:</code>的是实现是<strong>可选</strong>的。如果实现了，那么就会生成一个集合代理对象（其实就是一个<code>NSMutatableArray</code>的子类<code>NSKeyValueMutableArray</code>），这个<code>集合代理对象</code>和<code>NSArray</code>的操作没什么区别。并返回这个集合代理对象。否则，进行步骤3。</li>\n<li>如果对象同时实现了<code>countOf&lt;Key&gt;</code>, <code>enumeratorOf&lt;Key&gt;,</code> and <code>memberOf&lt;Key&gt;:</code>那么就会生成一个集合代理对象（其实就是一个<code>NSSet</code>的子类<code>NSKeyValueSet</code>），这个<code>集合代理对象</code>和<code>NSSet</code>的操作没什么区别。并返回这个集合代理对象。否则，进行步骤4。</li>\n<li>查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, 或者<code>is&lt;Key&gt;</code>,然后直接获取值，进行步骤5。否则进行步骤6。</li>\n<li>如果是<code>对象类型</code>，直接返回，如果是<code>int</code>、<code>struct</code>等数据类型封装成<code>NSNumber</code>或者<code>NSValue</code>。</li>\n<li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li>\n</ol>\n<p><br></p>\n<h5 id=\"通过Setter设值\"><a href=\"#通过Setter设值\" class=\"headerlink\" title=\"通过Setter设值\"></a>通过Setter设值</h5><p>当调用方法<code>setValue:forKey:</code>时，按照以下流程处理：</p>\n<ol>\n<li>安装顺序寻找方法 <code>set&lt;Key&gt;:</code> ， <code>_set&lt;Key&gt;</code>，如果找到了把输入的值当做参数传入其中。</li>\n<li>查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>_is&lt;Key&gt;</code>, <code>&lt;key&gt;</code>, 或者<code>is&lt;Key&gt;</code>,然后直接获赋值。</li>\n<li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li>\n</ol>\n<p><br></p>\n<h5 id=\"返回可变数组-Mutable-Ordered-Sets\"><a href=\"#返回可变数组-Mutable-Ordered-Sets\" class=\"headerlink\" title=\"返回可变数组/Mutable Ordered Sets\"></a>返回可变数组/Mutable Ordered Sets</h5><p>当调用方法<code>mutableArrayValueForKey:</code>或者<code>mutableOrderedSetValueForKey:</code>时，按照以下流程处理：</p>\n<ol>\n<li><p>判断是否实现以下方法</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这两个方法和 NSMutableArray/NSMutableOrderedSet 的方法 insertObject:atIndex: 和 removeObjectAtIndex: 对应</span></span><br><span class=\"line\">insertObject:<span class=\"keyword\">in</span>&lt;Key&gt;AtIndex:</span><br><span class=\"line\">removeObjectFrom&lt;Key&gt;AtIndex:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这两个方法和 NSMutableArray/NSMutableOrderedSet 的方法 insertObjects:atIndexes: 和 removeObjectsAtIndexes: 对应</span></span><br><span class=\"line\">insert&lt;Key&gt;:atIndexes: </span><br><span class=\"line\">remove&lt;Key&gt;AtIndexes:</span><br></pre></td></tr></table></figure>\n<p>   中的一个<strong>插入</strong>和<strong>移除</strong>方法。如果实现了，那么就返回一个代理对象。否则进行步骤2。而对于方法</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">replaceObjectIn&lt;Key&gt;AtIndex:withObject: </span><br><span class=\"line\">    <span class=\"comment\">//或者</span></span><br><span class=\"line\">replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;:</span><br></pre></td></tr></table></figure>\n<p> 可以增强效果。</p>\n</li>\n<li>寻找 <code>set&lt;Key&gt;:</code>方法。</li>\n<li>如果<code>array / mtuableOrderSet</code>的方法和 <code>set&lt;Key&gt;:</code>都没有寻找到。查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>&lt;key&gt;</code>,如果找到了，会生成一个代理对象，这个对象会把NSMutableArray的方法发送给这个实例变量。</li>\n<li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li>\n</ol>\n<p><br></p>\n<h5 id=\"返回mutableSet\"><a href=\"#返回mutableSet\" class=\"headerlink\" title=\"返回mutableSet\"></a>返回mutableSet</h5><p>当调用方法<code>mutableSetValueForKey:</code>时，按照以下流程处理：</p>\n<ol>\n<li><p>判断是否实现以下方法</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这两个方法和  NSMutableSet 的方法  addObject: 和  removeObject: 对应</span></span><br><span class=\"line\">add&lt;Key&gt;Object:</span><br><span class=\"line\">remove&lt;Key&gt;Object:</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 这两个方法和  NSMutableSet 的方法  unionSet: 和  minusSet: 对应</span></span><br><span class=\"line\">add&lt;Key&gt;:</span><br><span class=\"line\">remove&lt;Key&gt;:</span><br></pre></td></tr></table></figure>\n<p> 中的一个<strong>添加</strong>和<strong>移除</strong>方法。如果实现了，那么就返回一个代理对象。否则进行步骤2。而对于方法</p>\n <figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">intersect&lt;Key&gt;:</span><br><span class=\"line\">set&lt;Key&gt;:</span><br></pre></td></tr></table></figure>\n<p> 可以增强效果。</p>\n</li>\n<li><p>如果响应 <code>mutableSetValueForKey:</code>的对象是一个<code>managed object</code>（像<code>CoreData的Managed Object</code>）,查询将停止。</p>\n</li>\n<li>寻找 <code>set&lt;Key&gt;:</code>方法。</li>\n<li>如果<code>array / mtuableOrderSet</code>的方法和 <code>set&lt;Key&gt;:</code>都没有寻找到。查看对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回的值是<code>YES</code>,那么按照顺序寻找实例变量<code>_&lt;key&gt;</code>, <code>&lt;key&gt;</code>,如果找到了，会生成一个代理对象，这个对象会把NSMutableArray的方法发送给这个实例变量。</li>\n<li>触发<code>valueForUndefinedKey</code>:方法，抛出异常。</li>\n</ol>\n<p><br><br>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955-CJBBBFFA\" target=\"_blank\" rel=\"noopener\">Key-Value Coding Programming Guide</a></li>\n</ul>\n"},{"title":"KVO探索与实践","date":"2017-04-12T09:41:56.000Z","_content":"# KVO探索与实践\n\n###\t基础\n\n```objc\n- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context\n```\n这里有两个需要掌握的知识点：\n#### `1. options`\n* NSKeyValueObservingOptionNew：最新的`value`\n* NSKeyValueObservingOptionOld：之前的`value`\n* NSKeyValueObservingOptionInitial: 在注册成观察者之前就会向观察者发送一条同时\n* NSKeyValueObservingOptionPrior: 在调用\n`- (void)willChangeValueForKey:(NSString *)key`之前被调用\n\n#### `2. context`\n这个参数可以给观察者发送一些数据，多用于区分`keyPath`，当然是用响应通知的KeyPath也能区分。\n\n```objc\nvoid *ChangeNameContenxt = &ChangeNameContenxt;\n\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {\n    //way one\n    if ([keyPath isEqualToString:@\"name\"]) {\n        \n    }\n    //or\n    //way two\n    if (context == ChangeNameContenxt) {\n        \n    }\n}\n```\n\n<br>\n### 实践探索\n\n#### To-One\n\n**1. 自动发送（Automatic Change Notification）**\n\n这里就是一般使用的KVO的场景，省略。\n<br>\n**2. 手动发送（ Manual Notification）**\n首先要重写方法：\n\n```objc\n+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key\n```\n根据key判断哪些属性需要手动触发KVO,它还可以用另外一个简单的方法代替：\n\n```objc\n+ (BOOL)automaticallyNotifiesObserversOf*Key*\n```\n此处的key就是需要手动触发KVO的属性。另外，还需要在setter里面手动触发消息，在赋值之前调用：\n\n```objc\n- (void)willChangeValueForKey:(NSString *)key;\n```\n\n在赋值完成后调用：\n\n```objc\n- (void)didChangeValueForKey:(NSString *)key;\n```\n<br>\n#### To-Many\n了解这个知识点之前，需要知道`NSKeyValueChange`:\n\n* `NSKeyValueChangeSetting`: 赋值通知（默认）\n* `NSKeyValueChangeInsertion`: 插入通知\n* `NSKeyValueChangeRemoval`: 删除通知\n* `NSKeyValueChangeReplacement`: 替换通知\n\n当需要观察的属性是一个`Collection`的时候，单纯的观察属性是不在`Collection`进行`添加`、`删除`、`替换`操作是能获取到通知。所以需手动触发KVO.\n首先要重写方法：\n\n```objc\n+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key\n或者\n+ (BOOL)automaticallyNotifiesObserversOf*Key*\n```\n然后要在改变之前调用：\n\n```objc\n- (void)willChange:(NSKeyValueChange)changeKind valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key;\n```\n改变之后调用\n\n```objc\n- (void)didChange:(NSKeyValueChange)changeKind valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key;\n```\n这两个接口需要传入一个`NSIndexSet`对象，来确定进行`添加`、`删除`、`替换`操作的位置。\n<br>\n#### 相互影响的属性\n有些情况下，除了改变被观察的属性发生变化要发通知之外，修改某一属性的值也可能影响到被观察的属性，也要触发KVO通知。\n对于这种情况，需要重写：\n\n```objc\n+ (NSSet<NSString *> *)keyPathsForValuesAffectingValueForKey:(NSString *)key\n 或者\n + (NSSet<NSString *> *)keyPathsForValuesAffecting*Key*\n```\n把相关的属性通过`NSSet`返回。除此之外，还需要重写被观察属性的`getter`方法，表明被观察属性和影响属性的关系**（如果不写：那么接收KVO的方法返回的值就不会和影响属性有关系）**。\n例如，姓名由姓和名组成，那么改变姓或者名，那么这个姓名就会发生变化。\n\n```objc\n// .h\n@property (nonatomic, strong) NSString *fullName;\n@property (nonatomic, strong) NSString *firstName;\n@property (nonatomic, strong) NSString *lastName;\n\n// .m\n+ (NSSet<NSString *> *)keyPathsForValuesAffectingFullName {\n    return [NSSet setWithObjects:@\"firstName\", @\"lastName\", nil];\n}\n\n- (NSString *)fullName {\n    return [NSString stringWithFormat:@\"%@-%@\", _firstName, _lastName];\n}\n```\n\n在观察的接受方法中：\n\n```objc\n- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary<NSKeyValueChangeKey, id> *)change context:(nullable void *)context\n```\n就会接收到`fullName`改变的通知\n\n<br>\n#### 深层嵌套属性\n> 假象一种场景：一个部门有一些工作者，当他们的工资发生变化是，统计部门的总工资也要变化。解决这一问题有两种方法；\n\n***解决方法一：*** 先分析，这里有两个模型 `Department`、`Employee`\n\n```objc\n// Department.h\n@property (nonatomic, strong) NSArray <Employee *> *employees;\n@property (nonatomic, assign) NSInteger totalSalary;\n```\n\n\n```\n// Employee.h\n@property (nonatomic, assign) NSInteger salary;\n```\n\n在初始化`Department`时，把`Department`注册成为`Employee`的观察者。\n例如：\n\n```objc\n// Department.m (init)\n - (instancetype)init {\n    self = [super init];\n    if (self) {\n        //array\n        NSMutableArray *array = [NSMutableArray array];\n        for (int i = 0 ; i < 10; i++) {\n            Employee *employe = [Employee new];\n            employe.salary = i;\n            [employe addObserver:self forKeyPath:@\"salary\" options:NSKeyValueObservingOptionNew context:nil];\n            [array addObject:employe];\n        }\n        _employees = [array copy];\n    }\n    return self;\n}\n```\n\n然后在接收KVO通知方法里面：\n\n```obj-c\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {\n    [self setTotalSalary:[[self valueForKeyPath:@\"employees.@sum.salary\"] integerValue]];\n}\n```\n这样观察`Department`的`totalSalary`属性就可以观察到变化了。\n\n***解决方法二：***使用`CoreData`来实现。\n<br>\n### 原理分析\n正如苹果官方文档里面的描述：\n\n>Automatic key-value observing is implemented using a technique called isa-swizzling.\n>\n>The isa pointer, as the name suggests, points to the object's class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.\n>\n>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.\n>\n>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.\n\n当某一属性被观察时，会生成一个中间类**（NSKVONotifying_原类名）**，改中间类会做一下处理\n\n* 重写`setter`，手动发送KVO通知。\n* 重写`class`方法，隐藏真实类名，不过可以用`object_getClass()`获取。\n* 添加方法`- (BOOL)_isKVOA`判断被动态生成KVO子类\n\n<br>\n### 注意\n<div class=\"tip\">\n\t<div>1. 在被观察对象释放的时候需要移除KVO</div>\n\t<div>2. 一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。</div>\n</div>\n\n<br>\n\n######  资料参考：\n * [Key-Value Observing Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA)\n * [objc kvo简单探索](http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/)\n\t\n\n","source":"_posts/KVO探索与实践.md","raw":"---\ntitle: KVO探索与实践\ndate: 2017-04-12 17:41:56\n---\n# KVO探索与实践\n\n###\t基础\n\n```objc\n- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context\n```\n这里有两个需要掌握的知识点：\n#### `1. options`\n* NSKeyValueObservingOptionNew：最新的`value`\n* NSKeyValueObservingOptionOld：之前的`value`\n* NSKeyValueObservingOptionInitial: 在注册成观察者之前就会向观察者发送一条同时\n* NSKeyValueObservingOptionPrior: 在调用\n`- (void)willChangeValueForKey:(NSString *)key`之前被调用\n\n#### `2. context`\n这个参数可以给观察者发送一些数据，多用于区分`keyPath`，当然是用响应通知的KeyPath也能区分。\n\n```objc\nvoid *ChangeNameContenxt = &ChangeNameContenxt;\n\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {\n    //way one\n    if ([keyPath isEqualToString:@\"name\"]) {\n        \n    }\n    //or\n    //way two\n    if (context == ChangeNameContenxt) {\n        \n    }\n}\n```\n\n<br>\n### 实践探索\n\n#### To-One\n\n**1. 自动发送（Automatic Change Notification）**\n\n这里就是一般使用的KVO的场景，省略。\n<br>\n**2. 手动发送（ Manual Notification）**\n首先要重写方法：\n\n```objc\n+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key\n```\n根据key判断哪些属性需要手动触发KVO,它还可以用另外一个简单的方法代替：\n\n```objc\n+ (BOOL)automaticallyNotifiesObserversOf*Key*\n```\n此处的key就是需要手动触发KVO的属性。另外，还需要在setter里面手动触发消息，在赋值之前调用：\n\n```objc\n- (void)willChangeValueForKey:(NSString *)key;\n```\n\n在赋值完成后调用：\n\n```objc\n- (void)didChangeValueForKey:(NSString *)key;\n```\n<br>\n#### To-Many\n了解这个知识点之前，需要知道`NSKeyValueChange`:\n\n* `NSKeyValueChangeSetting`: 赋值通知（默认）\n* `NSKeyValueChangeInsertion`: 插入通知\n* `NSKeyValueChangeRemoval`: 删除通知\n* `NSKeyValueChangeReplacement`: 替换通知\n\n当需要观察的属性是一个`Collection`的时候，单纯的观察属性是不在`Collection`进行`添加`、`删除`、`替换`操作是能获取到通知。所以需手动触发KVO.\n首先要重写方法：\n\n```objc\n+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key\n或者\n+ (BOOL)automaticallyNotifiesObserversOf*Key*\n```\n然后要在改变之前调用：\n\n```objc\n- (void)willChange:(NSKeyValueChange)changeKind valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key;\n```\n改变之后调用\n\n```objc\n- (void)didChange:(NSKeyValueChange)changeKind valuesAtIndexes:(NSIndexSet *)indexes forKey:(NSString *)key;\n```\n这两个接口需要传入一个`NSIndexSet`对象，来确定进行`添加`、`删除`、`替换`操作的位置。\n<br>\n#### 相互影响的属性\n有些情况下，除了改变被观察的属性发生变化要发通知之外，修改某一属性的值也可能影响到被观察的属性，也要触发KVO通知。\n对于这种情况，需要重写：\n\n```objc\n+ (NSSet<NSString *> *)keyPathsForValuesAffectingValueForKey:(NSString *)key\n 或者\n + (NSSet<NSString *> *)keyPathsForValuesAffecting*Key*\n```\n把相关的属性通过`NSSet`返回。除此之外，还需要重写被观察属性的`getter`方法，表明被观察属性和影响属性的关系**（如果不写：那么接收KVO的方法返回的值就不会和影响属性有关系）**。\n例如，姓名由姓和名组成，那么改变姓或者名，那么这个姓名就会发生变化。\n\n```objc\n// .h\n@property (nonatomic, strong) NSString *fullName;\n@property (nonatomic, strong) NSString *firstName;\n@property (nonatomic, strong) NSString *lastName;\n\n// .m\n+ (NSSet<NSString *> *)keyPathsForValuesAffectingFullName {\n    return [NSSet setWithObjects:@\"firstName\", @\"lastName\", nil];\n}\n\n- (NSString *)fullName {\n    return [NSString stringWithFormat:@\"%@-%@\", _firstName, _lastName];\n}\n```\n\n在观察的接受方法中：\n\n```objc\n- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary<NSKeyValueChangeKey, id> *)change context:(nullable void *)context\n```\n就会接收到`fullName`改变的通知\n\n<br>\n#### 深层嵌套属性\n> 假象一种场景：一个部门有一些工作者，当他们的工资发生变化是，统计部门的总工资也要变化。解决这一问题有两种方法；\n\n***解决方法一：*** 先分析，这里有两个模型 `Department`、`Employee`\n\n```objc\n// Department.h\n@property (nonatomic, strong) NSArray <Employee *> *employees;\n@property (nonatomic, assign) NSInteger totalSalary;\n```\n\n\n```\n// Employee.h\n@property (nonatomic, assign) NSInteger salary;\n```\n\n在初始化`Department`时，把`Department`注册成为`Employee`的观察者。\n例如：\n\n```objc\n// Department.m (init)\n - (instancetype)init {\n    self = [super init];\n    if (self) {\n        //array\n        NSMutableArray *array = [NSMutableArray array];\n        for (int i = 0 ; i < 10; i++) {\n            Employee *employe = [Employee new];\n            employe.salary = i;\n            [employe addObserver:self forKeyPath:@\"salary\" options:NSKeyValueObservingOptionNew context:nil];\n            [array addObject:employe];\n        }\n        _employees = [array copy];\n    }\n    return self;\n}\n```\n\n然后在接收KVO通知方法里面：\n\n```obj-c\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {\n    [self setTotalSalary:[[self valueForKeyPath:@\"employees.@sum.salary\"] integerValue]];\n}\n```\n这样观察`Department`的`totalSalary`属性就可以观察到变化了。\n\n***解决方法二：***使用`CoreData`来实现。\n<br>\n### 原理分析\n正如苹果官方文档里面的描述：\n\n>Automatic key-value observing is implemented using a technique called isa-swizzling.\n>\n>The isa pointer, as the name suggests, points to the object's class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.\n>\n>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.\n>\n>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.\n\n当某一属性被观察时，会生成一个中间类**（NSKVONotifying_原类名）**，改中间类会做一下处理\n\n* 重写`setter`，手动发送KVO通知。\n* 重写`class`方法，隐藏真实类名，不过可以用`object_getClass()`获取。\n* 添加方法`- (BOOL)_isKVOA`判断被动态生成KVO子类\n\n<br>\n### 注意\n<div class=\"tip\">\n\t<div>1. 在被观察对象释放的时候需要移除KVO</div>\n\t<div>2. 一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。</div>\n</div>\n\n<br>\n\n######  资料参考：\n * [Key-Value Observing Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA)\n * [objc kvo简单探索](http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/)\n\t\n\n","slug":"KVO探索与实践","published":1,"updated":"2018-03-27T07:54:00.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjghl49fv0001pnqk7bjbwjcw","content":"<h1 id=\"KVO探索与实践\"><a href=\"#KVO探索与实践\" class=\"headerlink\" title=\"KVO探索与实践\"></a>KVO探索与实践</h1><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)addObserver:(<span class=\"built_in\">NSObject</span> *)observer forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath options:(<span class=\"built_in\">NSKeyValueObservingOptions</span>)options context:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> *)context</span><br></pre></td></tr></table></figure>\n<p>这里有两个需要掌握的知识点：</p>\n<h4 id=\"1-options\"><a href=\"#1-options\" class=\"headerlink\" title=\"1. options\"></a><code>1. options</code></h4><ul>\n<li>NSKeyValueObservingOptionNew：最新的<code>value</code></li>\n<li>NSKeyValueObservingOptionOld：之前的<code>value</code></li>\n<li>NSKeyValueObservingOptionInitial: 在注册成观察者之前就会向观察者发送一条同时</li>\n<li>NSKeyValueObservingOptionPrior: 在调用<br><code>- (void)willChangeValueForKey:(NSString *)key</code>之前被调用</li>\n</ul>\n<h4 id=\"2-context\"><a href=\"#2-context\" class=\"headerlink\" title=\"2. context\"></a><code>2. context</code></h4><p>这个参数可以给观察者发送一些数据，多用于区分<code>keyPath</code>，当然是用响应通知的KeyPath也能区分。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> *ChangeNameContenxt = &amp;ChangeNameContenxt;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>,<span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">void</span> *)context &#123;</span><br><span class=\"line\">    <span class=\"comment\">//way one</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([keyPath isEqualToString:<span class=\"string\">@\"name\"</span>]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//or</span></span><br><span class=\"line\">    <span class=\"comment\">//way two</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == ChangeNameContenxt) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"实践探索\"><a href=\"#实践探索\" class=\"headerlink\" title=\"实践探索\"></a>实践探索</h3><h4 id=\"To-One\"><a href=\"#To-One\" class=\"headerlink\" title=\"To-One\"></a>To-One</h4><p><strong>1. 自动发送（Automatic Change Notification）</strong></p>\n<p>这里就是一般使用的KVO的场景，省略。<br><br><br><strong>2. 手动发送（ Manual Notification）</strong><br>首先要重写方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class=\"built_in\">NSString</span> *)key</span><br></pre></td></tr></table></figure>\n<p>根据key判断哪些属性需要手动触发KVO,它还可以用另外一个简单的方法代替：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversOf*Key*</span><br></pre></td></tr></table></figure>\n<p>此处的key就是需要手动触发KVO的属性。另外，还需要在setter里面手动触发消息，在赋值之前调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)willChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br></pre></td></tr></table></figure>\n<p>在赋值完成后调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h4 id=\"To-Many\"><a href=\"#To-Many\" class=\"headerlink\" title=\"To-Many\"></a>To-Many</h4><p>了解这个知识点之前，需要知道<code>NSKeyValueChange</code>:</p>\n<ul>\n<li><code>NSKeyValueChangeSetting</code>: 赋值通知（默认）</li>\n<li><code>NSKeyValueChangeInsertion</code>: 插入通知</li>\n<li><code>NSKeyValueChangeRemoval</code>: 删除通知</li>\n<li><code>NSKeyValueChangeReplacement</code>: 替换通知</li>\n</ul>\n<p>当需要观察的属性是一个<code>Collection</code>的时候，单纯的观察属性是不在<code>Collection</code>进行<code>添加</code>、<code>删除</code>、<code>替换</code>操作是能获取到通知。所以需手动触发KVO.<br>首先要重写方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\">或者</span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversOf*Key*</span><br></pre></td></tr></table></figure>\n<p>然后要在改变之前调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)willChange:(<span class=\"built_in\">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class=\"built_in\">NSIndexSet</span> *)indexes forKey:(<span class=\"built_in\">NSString</span> *)key;</span><br></pre></td></tr></table></figure>\n<p>改变之后调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)didChange:(<span class=\"built_in\">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class=\"built_in\">NSIndexSet</span> *)indexes forKey:(<span class=\"built_in\">NSString</span> *)key;</span><br></pre></td></tr></table></figure>\n<p>这两个接口需要传入一个<code>NSIndexSet</code>对象，来确定进行<code>添加</code>、<code>删除</code>、<code>替换</code>操作的位置。<br><br></p>\n<h4 id=\"相互影响的属性\"><a href=\"#相互影响的属性\" class=\"headerlink\" title=\"相互影响的属性\"></a>相互影响的属性</h4><p>有些情况下，除了改变被观察的属性发生变化要发通知之外，修改某一属性的值也可能影响到被观察的属性，也要触发KVO通知。<br>对于这种情况，需要重写：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\"> 或者</span><br><span class=\"line\"> + (<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keyPathsForValuesAffecting*Key*</span><br></pre></td></tr></table></figure>\n<p>把相关的属性通过<code>NSSet</code>返回。除此之外，还需要重写被观察属性的<code>getter</code>方法，表明被观察属性和影响属性的关系<strong>（如果不写：那么接收KVO的方法返回的值就不会和影响属性有关系）</strong>。<br>例如，姓名由姓和名组成，那么改变姓或者名，那么这个姓名就会发生变化。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *fullName;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *firstName;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *lastName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .m</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keyPathsForValuesAffectingFullName &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"firstName\"</span>, <span class=\"string\">@\"lastName\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)fullName &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@-%@\"</span>, _firstName, _lastName];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在观察的接受方法中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)object change:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>, <span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> *)context</span><br></pre></td></tr></table></figure>\n<p>就会接收到<code>fullName</code>改变的通知</p>\n<p><br></p>\n<h4 id=\"深层嵌套属性\"><a href=\"#深层嵌套属性\" class=\"headerlink\" title=\"深层嵌套属性\"></a>深层嵌套属性</h4><blockquote>\n<p>假象一种场景：一个部门有一些工作者，当他们的工资发生变化是，统计部门的总工资也要变化。解决这一问题有两种方法；</p>\n</blockquote>\n<p><strong><em>解决方法一：</em></strong> 先分析，这里有两个模型 <code>Department</code>、<code>Employee</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Department.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> &lt;Employee *&gt; *employees;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> totalSalary;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Employee.h</span><br><span class=\"line\">@property (nonatomic, assign) NSInteger salary;</span><br></pre></td></tr></table></figure>\n<p>在初始化<code>Department</code>时，把<code>Department</code>注册成为<code>Employee</code>的观察者。<br>例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Department.m (init)</span></span><br><span class=\"line\"> - (<span class=\"keyword\">instancetype</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//array</span></span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            Employee *employe = [Employee new];</span><br><span class=\"line\">            employe.salary = i;</span><br><span class=\"line\">            [employe addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"salary\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">            [array addObject:employe];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        _employees = [array <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在接收KVO通知方法里面：</p>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>,<span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">void</span> *)context &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setTotalSalary:[[<span class=\"keyword\">self</span> valueForKeyPath:<span class=\"string\">@\"employees.@sum.salary\"</span>] integerValue]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样观察<code>Department</code>的<code>totalSalary</code>属性就可以观察到变化了。</p>\n<p><strong><em>解决方法二：</em></strong>使用<code>CoreData</code>来实现。<br><br></p>\n<h3 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h3><p>正如苹果官方文档里面的描述：</p>\n<blockquote>\n<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>\n<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>\n<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>\n<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>\n</blockquote>\n<p>当某一属性被观察时，会生成一个中间类<strong>（NSKVONotifying_原类名）</strong>，改中间类会做一下处理</p>\n<ul>\n<li>重写<code>setter</code>，手动发送KVO通知。</li>\n<li>重写<code>class</code>方法，隐藏真实类名，不过可以用<code>object_getClass()</code>获取。</li>\n<li>添加方法<code>- (BOOL)_isKVOA</code>判断被动态生成KVO子类</li>\n</ul>\n<p><br></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><div class=\"tip\"><br>    <div>1. 在被观察对象释放的时候需要移除KVO</div><br>    <div>2. 一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。</div><br></div>\n\n<p><br></p>\n<h6 id=\"资料参考：\"><a href=\"#资料参考：\" class=\"headerlink\" title=\"资料参考：\"></a>资料参考：</h6><ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA\" target=\"_blank\" rel=\"noopener\">Key-Value Observing Programming Guide</a></li>\n<li><a href=\"http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/\" target=\"_blank\" rel=\"noopener\">objc kvo简单探索</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"KVO探索与实践\"><a href=\"#KVO探索与实践\" class=\"headerlink\" title=\"KVO探索与实践\"></a>KVO探索与实践</h1><h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)addObserver:(<span class=\"built_in\">NSObject</span> *)observer forKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath options:(<span class=\"built_in\">NSKeyValueObservingOptions</span>)options context:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> *)context</span><br></pre></td></tr></table></figure>\n<p>这里有两个需要掌握的知识点：</p>\n<h4 id=\"1-options\"><a href=\"#1-options\" class=\"headerlink\" title=\"1. options\"></a><code>1. options</code></h4><ul>\n<li>NSKeyValueObservingOptionNew：最新的<code>value</code></li>\n<li>NSKeyValueObservingOptionOld：之前的<code>value</code></li>\n<li>NSKeyValueObservingOptionInitial: 在注册成观察者之前就会向观察者发送一条同时</li>\n<li>NSKeyValueObservingOptionPrior: 在调用<br><code>- (void)willChangeValueForKey:(NSString *)key</code>之前被调用</li>\n</ul>\n<h4 id=\"2-context\"><a href=\"#2-context\" class=\"headerlink\" title=\"2. context\"></a><code>2. context</code></h4><p>这个参数可以给观察者发送一些数据，多用于区分<code>keyPath</code>，当然是用响应通知的KeyPath也能区分。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> *ChangeNameContenxt = &amp;ChangeNameContenxt;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>,<span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">void</span> *)context &#123;</span><br><span class=\"line\">    <span class=\"comment\">//way one</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([keyPath isEqualToString:<span class=\"string\">@\"name\"</span>]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//or</span></span><br><span class=\"line\">    <span class=\"comment\">//way two</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == ChangeNameContenxt) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"实践探索\"><a href=\"#实践探索\" class=\"headerlink\" title=\"实践探索\"></a>实践探索</h3><h4 id=\"To-One\"><a href=\"#To-One\" class=\"headerlink\" title=\"To-One\"></a>To-One</h4><p><strong>1. 自动发送（Automatic Change Notification）</strong></p>\n<p>这里就是一般使用的KVO的场景，省略。<br><br><br><strong>2. 手动发送（ Manual Notification）</strong><br>首先要重写方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class=\"built_in\">NSString</span> *)key</span><br></pre></td></tr></table></figure>\n<p>根据key判断哪些属性需要手动触发KVO,它还可以用另外一个简单的方法代替：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversOf*Key*</span><br></pre></td></tr></table></figure>\n<p>此处的key就是需要手动触发KVO的属性。另外，还需要在setter里面手动触发消息，在赋值之前调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)willChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br></pre></td></tr></table></figure>\n<p>在赋值完成后调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)didChangeValueForKey:(<span class=\"built_in\">NSString</span> *)key;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h4 id=\"To-Many\"><a href=\"#To-Many\" class=\"headerlink\" title=\"To-Many\"></a>To-Many</h4><p>了解这个知识点之前，需要知道<code>NSKeyValueChange</code>:</p>\n<ul>\n<li><code>NSKeyValueChangeSetting</code>: 赋值通知（默认）</li>\n<li><code>NSKeyValueChangeInsertion</code>: 插入通知</li>\n<li><code>NSKeyValueChangeRemoval</code>: 删除通知</li>\n<li><code>NSKeyValueChangeReplacement</code>: 替换通知</li>\n</ul>\n<p>当需要观察的属性是一个<code>Collection</code>的时候，单纯的观察属性是不在<code>Collection</code>进行<code>添加</code>、<code>删除</code>、<code>替换</code>操作是能获取到通知。所以需手动触发KVO.<br>首先要重写方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\">或者</span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)automaticallyNotifiesObserversOf*Key*</span><br></pre></td></tr></table></figure>\n<p>然后要在改变之前调用：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)willChange:(<span class=\"built_in\">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class=\"built_in\">NSIndexSet</span> *)indexes forKey:(<span class=\"built_in\">NSString</span> *)key;</span><br></pre></td></tr></table></figure>\n<p>改变之后调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)didChange:(<span class=\"built_in\">NSKeyValueChange</span>)changeKind valuesAtIndexes:(<span class=\"built_in\">NSIndexSet</span> *)indexes forKey:(<span class=\"built_in\">NSString</span> *)key;</span><br></pre></td></tr></table></figure>\n<p>这两个接口需要传入一个<code>NSIndexSet</code>对象，来确定进行<code>添加</code>、<code>删除</code>、<code>替换</code>操作的位置。<br><br></p>\n<h4 id=\"相互影响的属性\"><a href=\"#相互影响的属性\" class=\"headerlink\" title=\"相互影响的属性\"></a>相互影响的属性</h4><p>有些情况下，除了改变被观察的属性发生变化要发通知之外，修改某一属性的值也可能影响到被观察的属性，也要触发KVO通知。<br>对于这种情况，需要重写：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\"> 或者</span><br><span class=\"line\"> + (<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keyPathsForValuesAffecting*Key*</span><br></pre></td></tr></table></figure>\n<p>把相关的属性通过<code>NSSet</code>返回。除此之外，还需要重写被观察属性的<code>getter</code>方法，表明被观察属性和影响属性的关系<strong>（如果不写：那么接收KVO的方法返回的值就不会和影响属性有关系）</strong>。<br>例如，姓名由姓和名组成，那么改变姓或者名，那么这个姓名就会发生变化。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *fullName;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *firstName;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *lastName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .m</span></span><br><span class=\"line\">+ (<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">NSString</span> *&gt; *)keyPathsForValuesAffectingFullName &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSSet</span> setWithObjects:<span class=\"string\">@\"firstName\"</span>, <span class=\"string\">@\"lastName\"</span>, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)fullName &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@\"%@-%@\"</span>, _firstName, _lastName];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在观察的接受方法中：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">id</span>)object change:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>, <span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">nullable</span> <span class=\"keyword\">void</span> *)context</span><br></pre></td></tr></table></figure>\n<p>就会接收到<code>fullName</code>改变的通知</p>\n<p><br></p>\n<h4 id=\"深层嵌套属性\"><a href=\"#深层嵌套属性\" class=\"headerlink\" title=\"深层嵌套属性\"></a>深层嵌套属性</h4><blockquote>\n<p>假象一种场景：一个部门有一些工作者，当他们的工资发生变化是，统计部门的总工资也要变化。解决这一问题有两种方法；</p>\n</blockquote>\n<p><strong><em>解决方法一：</em></strong> 先分析，这里有两个模型 <code>Department</code>、<code>Employee</code></p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Department.h</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSArray</span> &lt;Employee *&gt; *employees;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> totalSalary;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Employee.h</span><br><span class=\"line\">@property (nonatomic, assign) NSInteger salary;</span><br></pre></td></tr></table></figure>\n<p>在初始化<code>Department</code>时，把<code>Department</code>注册成为<code>Employee</code>的观察者。<br>例如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Department.m (init)</span></span><br><span class=\"line\"> - (<span class=\"keyword\">instancetype</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//array</span></span><br><span class=\"line\">        <span class=\"built_in\">NSMutableArray</span> *array = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            Employee *employe = [Employee new];</span><br><span class=\"line\">            employe.salary = i;</span><br><span class=\"line\">            [employe addObserver:<span class=\"keyword\">self</span> forKeyPath:<span class=\"string\">@\"salary\"</span> options:<span class=\"built_in\">NSKeyValueObservingOptionNew</span> context:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">            [array addObject:employe];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        _employees = [array <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在接收KVO通知方法里面：</p>\n<figure class=\"highlight obj-c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)observeValueForKeyPath:(<span class=\"built_in\">NSString</span> *)keyPath ofObject:(<span class=\"keyword\">id</span>)object change:(<span class=\"built_in\">NSDictionary</span>&lt;<span class=\"built_in\">NSKeyValueChangeKey</span>,<span class=\"keyword\">id</span>&gt; *)change context:(<span class=\"keyword\">void</span> *)context &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setTotalSalary:[[<span class=\"keyword\">self</span> valueForKeyPath:<span class=\"string\">@\"employees.@sum.salary\"</span>] integerValue]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样观察<code>Department</code>的<code>totalSalary</code>属性就可以观察到变化了。</p>\n<p><strong><em>解决方法二：</em></strong>使用<code>CoreData</code>来实现。<br><br></p>\n<h3 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h3><p>正如苹果官方文档里面的描述：</p>\n<blockquote>\n<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>\n<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>\n<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>\n<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>\n</blockquote>\n<p>当某一属性被观察时，会生成一个中间类<strong>（NSKVONotifying_原类名）</strong>，改中间类会做一下处理</p>\n<ul>\n<li>重写<code>setter</code>，手动发送KVO通知。</li>\n<li>重写<code>class</code>方法，隐藏真实类名，不过可以用<code>object_getClass()</code>获取。</li>\n<li>添加方法<code>- (BOOL)_isKVOA</code>判断被动态生成KVO子类</li>\n</ul>\n<p><br></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><div class=\"tip\"><br>    <div>1. 在被观察对象释放的时候需要移除KVO</div><br>    <div>2. 一个需要注意的地方是，KVO 行为是同步的，并且发生与所观察的值发生变化的同样的线程上。</div><br></div>\n\n<p><br></p>\n<h6 id=\"资料参考：\"><a href=\"#资料参考：\" class=\"headerlink\" title=\"资料参考：\"></a>资料参考：</h6><ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA\" target=\"_blank\" rel=\"noopener\">Key-Value Observing Programming Guide</a></li>\n<li><a href=\"http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/\" target=\"_blank\" rel=\"noopener\">objc kvo简单探索</a></li>\n</ul>\n"},{"title":"探索iOS事件处理","date":"2017-06-27T03:27:14.000Z","_content":"# 探索iOS事件处理\n> 当我们点击`button`的时候，然后触发动作，这个过程表面上看似简单，但背后的流程是否真的弄明白了？是否我们可以用这些知识做一些什么功能呢？\n\n\n### 原理分析\n首先，分为四个过程来分析:\n\n* **事件产生**\n* **事件分发**\n* **事件目标确定**\n* **事件传递**\n\n#### 事件产生\n当用户生成的事件发生时，`UIKit`会创建一个事件对象，其中包含处理事件所需的信息。然后它将事件对象放入活动应用程序的事件队列中。对于触摸事件，该对象是一组打包在`UIEvent`对象中的触摸。对于运动事件，事件对象根据您使用的框架和您感兴趣的运动事件类型而异。事件的类型有 `TouchEvent`、`MotionEvent`、`RemotionEvent`。\n\n#### 事件分发\n`UIApplication`把事件充事件队列中拿出来，通过方法`sendEvent: `分发给`UIWindow`，然后`UIWindow`在调用方法`sendEvent:`发送给里面的控件。我们可以重写`sendEvent:`方法，来做一些事情，但是务必调用`[super sendEvent：theEvent]`。\n\n#### 事件目标确定\n怎样才能知道到底谁来处理这个事件呢？也就怎样寻找`FirstResponder`？`UIView`有个分类，里面有两个方法：\n\n```objc\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;\n- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;\n```\n父视图通过向子视图发送`pointInside: withEvent: `来判断是否触摸的点在子视图的bounds里面。然后通过消息`hitTest: withEvent:` 返回的`View`来处理这个事件。\n#### 事件传递\n但是如果`firstResponder`不处理事件，那么事件就会通过响应链（`response chain`）传递下去。应用程序使用响应者对象接收和处理事件。响应者对象是`UIResponder`类的任何实例，子类包括`UIView`，`UIViewController`和`UIApplication`。响应链的传递如下图。\n![](探索iOS事件处理/2.png)\n传递的规则如下：\n\n*  `UIView`对象。如果视图是视图控制器的根视图，则下一个响应者是视图控制器;否则，下一个响应者是视图的父视图。\n* `UIViewController`对象。<br>\n   *  如果视图控制器的视图是窗口的根视图，则下一个响应者是窗口对象。\n   * 如果视图控制器由另一个视图控制器呈现，则下一个响应者是   \n   呈现视图控制器。\n* `UIWindow`对象。窗口的下一个响应者是UIApplication对象。\n* `UIApplication`对象。下一个响应者是应用程序委托，但前提是应用程序委托是UIResponder的实例，并且不是视图，视图控制器或应用程序对象本身。\n\n如果想改变响应链路径，可以重写`nextResponder`;\n\n### 功能应用\n通过原理分析，我们可以得出一个结论和两个功能应用。\n\n**1. UIButton不能响应事件的情况** \n\n * `hidden = YES`\n * `alpha < 0.01`\n * `点击区域超出父视图`\n \n**2. 扩大UIButton的响应区域**\n    需要重写 `pointInside: withEvent:`,然后判断点位是否在响应的区域内。代码如下：\n    \n```objc\n- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {\n    //点击区域各个方向增加 50，这里需要看UIEdgeInsetsMake的实现\n    CGRect rect = UIEdgeInsetsInsetRect(self.bounds, UIEdgeInsetsMake(-50, -50, -50, -50));\n    return CGRectContainsPoint(rect, point);\n}\n```\n\n**3. 做一个滑动展示图**\n效果图如下:\n![](探索iOS事件处理/3.png)\n实现这个最简单的就是使用一个`UIScrollView`,然后设置属性`clipToBounds = NO`,`pagingEnabled = YES`。再把`内容视图`和`UIScrollView`按照要求：\n`内容宽 + padding  = scrollview宽度`；\n需要注意的是`第一个视图`和`最后一个视图`相距scrollView的content距离为 `padding/2`,这样才能有居中效果。\n\n[实验Demo](https://github.com/plumhly/HitTest_Ex)\n<br>\n### 参考资料：\n* [Understanding Event Handling, Responders, and the Responder Chain](https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/understanding_event_handling_responders_and_the_responder_chain?language=objc)\n* [UIScrollView 实践经验](http://tech.glowing.com/cn/practice-in-uiscrollview/)\n\n","source":"_posts/探索iOS事件处理.md","raw":"---\ntitle: 探索iOS事件处理\ndate: 2017-06-27 11:27:14\ntags:\n---\n# 探索iOS事件处理\n> 当我们点击`button`的时候，然后触发动作，这个过程表面上看似简单，但背后的流程是否真的弄明白了？是否我们可以用这些知识做一些什么功能呢？\n\n\n### 原理分析\n首先，分为四个过程来分析:\n\n* **事件产生**\n* **事件分发**\n* **事件目标确定**\n* **事件传递**\n\n#### 事件产生\n当用户生成的事件发生时，`UIKit`会创建一个事件对象，其中包含处理事件所需的信息。然后它将事件对象放入活动应用程序的事件队列中。对于触摸事件，该对象是一组打包在`UIEvent`对象中的触摸。对于运动事件，事件对象根据您使用的框架和您感兴趣的运动事件类型而异。事件的类型有 `TouchEvent`、`MotionEvent`、`RemotionEvent`。\n\n#### 事件分发\n`UIApplication`把事件充事件队列中拿出来，通过方法`sendEvent: `分发给`UIWindow`，然后`UIWindow`在调用方法`sendEvent:`发送给里面的控件。我们可以重写`sendEvent:`方法，来做一些事情，但是务必调用`[super sendEvent：theEvent]`。\n\n#### 事件目标确定\n怎样才能知道到底谁来处理这个事件呢？也就怎样寻找`FirstResponder`？`UIView`有个分类，里面有两个方法：\n\n```objc\n- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;\n- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;\n```\n父视图通过向子视图发送`pointInside: withEvent: `来判断是否触摸的点在子视图的bounds里面。然后通过消息`hitTest: withEvent:` 返回的`View`来处理这个事件。\n#### 事件传递\n但是如果`firstResponder`不处理事件，那么事件就会通过响应链（`response chain`）传递下去。应用程序使用响应者对象接收和处理事件。响应者对象是`UIResponder`类的任何实例，子类包括`UIView`，`UIViewController`和`UIApplication`。响应链的传递如下图。\n![](探索iOS事件处理/2.png)\n传递的规则如下：\n\n*  `UIView`对象。如果视图是视图控制器的根视图，则下一个响应者是视图控制器;否则，下一个响应者是视图的父视图。\n* `UIViewController`对象。<br>\n   *  如果视图控制器的视图是窗口的根视图，则下一个响应者是窗口对象。\n   * 如果视图控制器由另一个视图控制器呈现，则下一个响应者是   \n   呈现视图控制器。\n* `UIWindow`对象。窗口的下一个响应者是UIApplication对象。\n* `UIApplication`对象。下一个响应者是应用程序委托，但前提是应用程序委托是UIResponder的实例，并且不是视图，视图控制器或应用程序对象本身。\n\n如果想改变响应链路径，可以重写`nextResponder`;\n\n### 功能应用\n通过原理分析，我们可以得出一个结论和两个功能应用。\n\n**1. UIButton不能响应事件的情况** \n\n * `hidden = YES`\n * `alpha < 0.01`\n * `点击区域超出父视图`\n \n**2. 扩大UIButton的响应区域**\n    需要重写 `pointInside: withEvent:`,然后判断点位是否在响应的区域内。代码如下：\n    \n```objc\n- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {\n    //点击区域各个方向增加 50，这里需要看UIEdgeInsetsMake的实现\n    CGRect rect = UIEdgeInsetsInsetRect(self.bounds, UIEdgeInsetsMake(-50, -50, -50, -50));\n    return CGRectContainsPoint(rect, point);\n}\n```\n\n**3. 做一个滑动展示图**\n效果图如下:\n![](探索iOS事件处理/3.png)\n实现这个最简单的就是使用一个`UIScrollView`,然后设置属性`clipToBounds = NO`,`pagingEnabled = YES`。再把`内容视图`和`UIScrollView`按照要求：\n`内容宽 + padding  = scrollview宽度`；\n需要注意的是`第一个视图`和`最后一个视图`相距scrollView的content距离为 `padding/2`,这样才能有居中效果。\n\n[实验Demo](https://github.com/plumhly/HitTest_Ex)\n<br>\n### 参考资料：\n* [Understanding Event Handling, Responders, and the Responder Chain](https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/understanding_event_handling_responders_and_the_responder_chain?language=objc)\n* [UIScrollView 实践经验](http://tech.glowing.com/cn/practice-in-uiscrollview/)\n\n","slug":"探索iOS事件处理","published":1,"updated":"2018-04-27T06:35:10.655Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjghl49fy0002pnqkkkgmk9l4","content":"<h1 id=\"探索iOS事件处理\"><a href=\"#探索iOS事件处理\" class=\"headerlink\" title=\"探索iOS事件处理\"></a>探索iOS事件处理</h1><blockquote>\n<p>当我们点击<code>button</code>的时候，然后触发动作，这个过程表面上看似简单，但背后的流程是否真的弄明白了？是否我们可以用这些知识做一些什么功能呢？</p>\n</blockquote>\n<h3 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h3><p>首先，分为四个过程来分析:</p>\n<ul>\n<li><strong>事件产生</strong></li>\n<li><strong>事件分发</strong></li>\n<li><strong>事件目标确定</strong></li>\n<li><strong>事件传递</strong></li>\n</ul>\n<h4 id=\"事件产生\"><a href=\"#事件产生\" class=\"headerlink\" title=\"事件产生\"></a>事件产生</h4><p>当用户生成的事件发生时，<code>UIKit</code>会创建一个事件对象，其中包含处理事件所需的信息。然后它将事件对象放入活动应用程序的事件队列中。对于触摸事件，该对象是一组打包在<code>UIEvent</code>对象中的触摸。对于运动事件，事件对象根据您使用的框架和您感兴趣的运动事件类型而异。事件的类型有 <code>TouchEvent</code>、<code>MotionEvent</code>、<code>RemotionEvent</code>。</p>\n<h4 id=\"事件分发\"><a href=\"#事件分发\" class=\"headerlink\" title=\"事件分发\"></a>事件分发</h4><p><code>UIApplication</code>把事件充事件队列中拿出来，通过方法<code>sendEvent:</code>分发给<code>UIWindow</code>，然后<code>UIWindow</code>在调用方法<code>sendEvent:</code>发送给里面的控件。我们可以重写<code>sendEvent:</code>方法，来做一些事情，但是务必调用<code>[super sendEvent：theEvent]</code>。</p>\n<h4 id=\"事件目标确定\"><a href=\"#事件目标确定\" class=\"headerlink\" title=\"事件目标确定\"></a>事件目标确定</h4><p>怎样才能知道到底谁来处理这个事件呢？也就怎样寻找<code>FirstResponder</code>？<code>UIView</code>有个分类，里面有两个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIView</span> *)hitTest:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)pointInside:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>\n<p>父视图通过向子视图发送<code>pointInside: withEvent:</code>来判断是否触摸的点在子视图的bounds里面。然后通过消息<code>hitTest: withEvent:</code> 返回的<code>View</code>来处理这个事件。</p>\n<h4 id=\"事件传递\"><a href=\"#事件传递\" class=\"headerlink\" title=\"事件传递\"></a>事件传递</h4><p>但是如果<code>firstResponder</code>不处理事件，那么事件就会通过响应链（<code>response chain</code>）传递下去。应用程序使用响应者对象接收和处理事件。响应者对象是<code>UIResponder</code>类的任何实例，子类包括<code>UIView</code>，<code>UIViewController</code>和<code>UIApplication</code>。响应链的传递如下图。<br><img src=\"/2017/06/27/探索iOS事件处理/2.png\" alt=\"\"><br>传递的规则如下：</p>\n<ul>\n<li><code>UIView</code>对象。如果视图是视图控制器的根视图，则下一个响应者是视图控制器;否则，下一个响应者是视图的父视图。</li>\n<li><code>UIViewController</code>对象。<br><ul>\n<li>如果视图控制器的视图是窗口的根视图，则下一个响应者是窗口对象。</li>\n<li>如果视图控制器由另一个视图控制器呈现，则下一个响应者是<br>呈现视图控制器。</li>\n</ul>\n</li>\n<li><code>UIWindow</code>对象。窗口的下一个响应者是UIApplication对象。</li>\n<li><code>UIApplication</code>对象。下一个响应者是应用程序委托，但前提是应用程序委托是UIResponder的实例，并且不是视图，视图控制器或应用程序对象本身。</li>\n</ul>\n<p>如果想改变响应链路径，可以重写<code>nextResponder</code>;</p>\n<h3 id=\"功能应用\"><a href=\"#功能应用\" class=\"headerlink\" title=\"功能应用\"></a>功能应用</h3><p>通过原理分析，我们可以得出一个结论和两个功能应用。</p>\n<p><strong>1. UIButton不能响应事件的情况</strong> </p>\n<ul>\n<li><code>hidden = YES</code></li>\n<li><code>alpha &lt; 0.01</code></li>\n<li><code>点击区域超出父视图</code></li>\n</ul>\n<p><strong>2. 扩大UIButton的响应区域</strong><br>    需要重写 <code>pointInside: withEvent:</code>,然后判断点位是否在响应的区域内。代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)pointInside:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</span><br><span class=\"line\">    <span class=\"comment\">//点击区域各个方向增加 50，这里需要看UIEdgeInsetsMake的实现</span></span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">UIEdgeInsetsInsetRect</span>(<span class=\"keyword\">self</span>.bounds, <span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">-50</span>, <span class=\"number\">-50</span>, <span class=\"number\">-50</span>, <span class=\"number\">-50</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CGRectContainsPoint</span>(rect, point);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3. 做一个滑动展示图</strong><br>效果图如下:<br><img src=\"/2017/06/27/探索iOS事件处理/3.png\" alt=\"\"><br>实现这个最简单的就是使用一个<code>UIScrollView</code>,然后设置属性<code>clipToBounds = NO</code>,<code>pagingEnabled = YES</code>。再把<code>内容视图</code>和<code>UIScrollView</code>按照要求：<br><code>内容宽 + padding  = scrollview宽度</code>；<br>需要注意的是<code>第一个视图</code>和<code>最后一个视图</code>相距scrollView的content距离为 <code>padding/2</code>,这样才能有居中效果。</p>\n<p><a href=\"https://github.com/plumhly/HitTest_Ex\" target=\"_blank\" rel=\"noopener\">实验Demo</a><br><br></p>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><ul>\n<li><a href=\"https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/understanding_event_handling_responders_and_the_responder_chain?language=objc\" target=\"_blank\" rel=\"noopener\">Understanding Event Handling, Responders, and the Responder Chain</a></li>\n<li><a href=\"http://tech.glowing.com/cn/practice-in-uiscrollview/\" target=\"_blank\" rel=\"noopener\">UIScrollView 实践经验</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"探索iOS事件处理\"><a href=\"#探索iOS事件处理\" class=\"headerlink\" title=\"探索iOS事件处理\"></a>探索iOS事件处理</h1><blockquote>\n<p>当我们点击<code>button</code>的时候，然后触发动作，这个过程表面上看似简单，但背后的流程是否真的弄明白了？是否我们可以用这些知识做一些什么功能呢？</p>\n</blockquote>\n<h3 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h3><p>首先，分为四个过程来分析:</p>\n<ul>\n<li><strong>事件产生</strong></li>\n<li><strong>事件分发</strong></li>\n<li><strong>事件目标确定</strong></li>\n<li><strong>事件传递</strong></li>\n</ul>\n<h4 id=\"事件产生\"><a href=\"#事件产生\" class=\"headerlink\" title=\"事件产生\"></a>事件产生</h4><p>当用户生成的事件发生时，<code>UIKit</code>会创建一个事件对象，其中包含处理事件所需的信息。然后它将事件对象放入活动应用程序的事件队列中。对于触摸事件，该对象是一组打包在<code>UIEvent</code>对象中的触摸。对于运动事件，事件对象根据您使用的框架和您感兴趣的运动事件类型而异。事件的类型有 <code>TouchEvent</code>、<code>MotionEvent</code>、<code>RemotionEvent</code>。</p>\n<h4 id=\"事件分发\"><a href=\"#事件分发\" class=\"headerlink\" title=\"事件分发\"></a>事件分发</h4><p><code>UIApplication</code>把事件充事件队列中拿出来，通过方法<code>sendEvent:</code>分发给<code>UIWindow</code>，然后<code>UIWindow</code>在调用方法<code>sendEvent:</code>发送给里面的控件。我们可以重写<code>sendEvent:</code>方法，来做一些事情，但是务必调用<code>[super sendEvent：theEvent]</code>。</p>\n<h4 id=\"事件目标确定\"><a href=\"#事件目标确定\" class=\"headerlink\" title=\"事件目标确定\"></a>事件目标确定</h4><p>怎样才能知道到底谁来处理这个事件呢？也就怎样寻找<code>FirstResponder</code>？<code>UIView</code>有个分类，里面有两个方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIView</span> *)hitTest:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)pointInside:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>\n<p>父视图通过向子视图发送<code>pointInside: withEvent:</code>来判断是否触摸的点在子视图的bounds里面。然后通过消息<code>hitTest: withEvent:</code> 返回的<code>View</code>来处理这个事件。</p>\n<h4 id=\"事件传递\"><a href=\"#事件传递\" class=\"headerlink\" title=\"事件传递\"></a>事件传递</h4><p>但是如果<code>firstResponder</code>不处理事件，那么事件就会通过响应链（<code>response chain</code>）传递下去。应用程序使用响应者对象接收和处理事件。响应者对象是<code>UIResponder</code>类的任何实例，子类包括<code>UIView</code>，<code>UIViewController</code>和<code>UIApplication</code>。响应链的传递如下图。<br><img src=\"/2017/06/27/探索iOS事件处理/2.png\" alt=\"\"><br>传递的规则如下：</p>\n<ul>\n<li><code>UIView</code>对象。如果视图是视图控制器的根视图，则下一个响应者是视图控制器;否则，下一个响应者是视图的父视图。</li>\n<li><code>UIViewController</code>对象。<br><ul>\n<li>如果视图控制器的视图是窗口的根视图，则下一个响应者是窗口对象。</li>\n<li>如果视图控制器由另一个视图控制器呈现，则下一个响应者是<br>呈现视图控制器。</li>\n</ul>\n</li>\n<li><code>UIWindow</code>对象。窗口的下一个响应者是UIApplication对象。</li>\n<li><code>UIApplication</code>对象。下一个响应者是应用程序委托，但前提是应用程序委托是UIResponder的实例，并且不是视图，视图控制器或应用程序对象本身。</li>\n</ul>\n<p>如果想改变响应链路径，可以重写<code>nextResponder</code>;</p>\n<h3 id=\"功能应用\"><a href=\"#功能应用\" class=\"headerlink\" title=\"功能应用\"></a>功能应用</h3><p>通过原理分析，我们可以得出一个结论和两个功能应用。</p>\n<p><strong>1. UIButton不能响应事件的情况</strong> </p>\n<ul>\n<li><code>hidden = YES</code></li>\n<li><code>alpha &lt; 0.01</code></li>\n<li><code>点击区域超出父视图</code></li>\n</ul>\n<p><strong>2. 扩大UIButton的响应区域</strong><br>    需要重写 <code>pointInside: withEvent:</code>,然后判断点位是否在响应的区域内。代码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)pointInside:(<span class=\"built_in\">CGPoint</span>)point withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</span><br><span class=\"line\">    <span class=\"comment\">//点击区域各个方向增加 50，这里需要看UIEdgeInsetsMake的实现</span></span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">UIEdgeInsetsInsetRect</span>(<span class=\"keyword\">self</span>.bounds, <span class=\"built_in\">UIEdgeInsetsMake</span>(<span class=\"number\">-50</span>, <span class=\"number\">-50</span>, <span class=\"number\">-50</span>, <span class=\"number\">-50</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CGRectContainsPoint</span>(rect, point);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3. 做一个滑动展示图</strong><br>效果图如下:<br><img src=\"/2017/06/27/探索iOS事件处理/3.png\" alt=\"\"><br>实现这个最简单的就是使用一个<code>UIScrollView</code>,然后设置属性<code>clipToBounds = NO</code>,<code>pagingEnabled = YES</code>。再把<code>内容视图</code>和<code>UIScrollView</code>按照要求：<br><code>内容宽 + padding  = scrollview宽度</code>；<br>需要注意的是<code>第一个视图</code>和<code>最后一个视图</code>相距scrollView的content距离为 <code>padding/2</code>,这样才能有居中效果。</p>\n<p><a href=\"https://github.com/plumhly/HitTest_Ex\" target=\"_blank\" rel=\"noopener\">实验Demo</a><br><br></p>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><ul>\n<li><a href=\"https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/understanding_event_handling_responders_and_the_responder_chain?language=objc\" target=\"_blank\" rel=\"noopener\">Understanding Event Handling, Responders, and the Responder Chain</a></li>\n<li><a href=\"http://tech.glowing.com/cn/practice-in-uiscrollview/\" target=\"_blank\" rel=\"noopener\">UIScrollView 实践经验</a></li>\n</ul>\n"},{"title":"字节序","date":"2017-03-22T09:41:56.000Z","_content":"# 字节序\n> 在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为`int`的变量`x`地址为`0x100`，那么其对应地址表达式`&x`的值为`0x100`。且`x`的四个字节将被存储在存储器的`0x100`, `0x101`, `0x102`, `0x103`位置。\n而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。\n例如假设上述变量`x`类型为`int`，位于地址`0x100`处，它的十六进制为`0x01234567`，地址范围为`0x100~0x103`字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：`0x100: 01, 0x101: 23,..`。而小端法将是：`0x100: 67, 0x101: 45,..`\n\n\n###网络字节序\n网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。\nBerkeley套接字定义了一组转换函数，用于`16bit`和`32bit`整数在网络序和本机字节序之间的转换。`htonl`，`htons`用于本机序转换到网络序；`ntohl`，`ntohs`用于网络序转换到本机序\n\n最近项目涉及到H264的编解码，传输的方式是采用socket其中解码的时候需要根据服务器传输的数据流的头部获取一些数据，比如屏幕宽、高、屏幕分辨率等，简单的说结构如下:\n\n```objc\nstruct Header {\n    unsigned int width;     //宽\n    unsigned int height;    //高\n    long int pixel;         //分辨率\n};\n```\n这里会出现什么问题呢？\n\n1. 网络字节序是采用`大端序`，简单的说就是把数据的高位存在低地址下。\n2. 数据流的的格式如下`<Header><NALU>`,所以我第一是要知道`Header`的长度，如果直接用`sizeof(Header)`获取产长度的话，获取的长度可能以为平台的不同而有出入，根本原因是因为`内存对齐`规则，这个我会在下一篇文章分享。\n\n###大端序和小端序（big-endian vs little-endian）\n其实大端序可以理解从左往右读取，小端序是从右往左读取。为了解释方便我们就用0x0A0B0C0D作为对象并且数据大小以8bit为单位。\n\n\n* ***大端序 (big-endian)***<br>\n地址增长方向 → <br>\n\n| ... | 0A | 0B | 0C | 0D | ...  |\n| --- | --- | --- | --- | --- | --- |\n示例中，最高位字节`0x0A` 存储在最低的内存地址处。下一个字节`0x0B`存在后面的地址处。正类似于十六进制字节`从左到右`的阅读顺序\n\n* ***小端序 (little-endian)*** <br>\n  地址增长方向 → <br>\n  \n| ... | 0D | 0C | 0B | 0A | ... |\n| --- | --- | --- | --- | --- | --- |\n最低位字节是`0x0D` 存储在最低的内存地址处。后面字节依次存在后面的地址处。\n\n\n","source":"_posts/字节序.md","raw":"---\ntitle: 字节序\ndate: 2017-03-22 17:41:56\n---\n# 字节序\n> 在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为`int`的变量`x`地址为`0x100`，那么其对应地址表达式`&x`的值为`0x100`。且`x`的四个字节将被存储在存储器的`0x100`, `0x101`, `0x102`, `0x103`位置。\n而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。\n例如假设上述变量`x`类型为`int`，位于地址`0x100`处，它的十六进制为`0x01234567`，地址范围为`0x100~0x103`字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：`0x100: 01, 0x101: 23,..`。而小端法将是：`0x100: 67, 0x101: 45,..`\n\n\n###网络字节序\n网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。\nBerkeley套接字定义了一组转换函数，用于`16bit`和`32bit`整数在网络序和本机字节序之间的转换。`htonl`，`htons`用于本机序转换到网络序；`ntohl`，`ntohs`用于网络序转换到本机序\n\n最近项目涉及到H264的编解码，传输的方式是采用socket其中解码的时候需要根据服务器传输的数据流的头部获取一些数据，比如屏幕宽、高、屏幕分辨率等，简单的说结构如下:\n\n```objc\nstruct Header {\n    unsigned int width;     //宽\n    unsigned int height;    //高\n    long int pixel;         //分辨率\n};\n```\n这里会出现什么问题呢？\n\n1. 网络字节序是采用`大端序`，简单的说就是把数据的高位存在低地址下。\n2. 数据流的的格式如下`<Header><NALU>`,所以我第一是要知道`Header`的长度，如果直接用`sizeof(Header)`获取产长度的话，获取的长度可能以为平台的不同而有出入，根本原因是因为`内存对齐`规则，这个我会在下一篇文章分享。\n\n###大端序和小端序（big-endian vs little-endian）\n其实大端序可以理解从左往右读取，小端序是从右往左读取。为了解释方便我们就用0x0A0B0C0D作为对象并且数据大小以8bit为单位。\n\n\n* ***大端序 (big-endian)***<br>\n地址增长方向 → <br>\n\n| ... | 0A | 0B | 0C | 0D | ...  |\n| --- | --- | --- | --- | --- | --- |\n示例中，最高位字节`0x0A` 存储在最低的内存地址处。下一个字节`0x0B`存在后面的地址处。正类似于十六进制字节`从左到右`的阅读顺序\n\n* ***小端序 (little-endian)*** <br>\n  地址增长方向 → <br>\n  \n| ... | 0D | 0C | 0B | 0A | ... |\n| --- | --- | --- | --- | --- | --- |\n最低位字节是`0x0D` 存储在最低的内存地址处。后面字节依次存在后面的地址处。\n\n\n","slug":"字节序","published":1,"updated":"2018-03-27T07:54:00.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjghl49fz0003pnqkrt3y61qm","content":"<h1 id=\"字节序\"><a href=\"#字节序\" class=\"headerlink\" title=\"字节序\"></a>字节序</h1><blockquote>\n<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为<code>int</code>的变量<code>x</code>地址为<code>0x100</code>，那么其对应地址表达式<code>&amp;x</code>的值为<code>0x100</code>。且<code>x</code>的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。<br>而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。<br>例如假设上述变量<code>x</code>类型为<code>int</code>，位于地址<code>0x100</code>处，它的十六进制为<code>0x01234567</code>，地址范围为<code>0x100~0x103</code>字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：<code>0x100: 01, 0x101: 23,..</code>。而小端法将是：<code>0x100: 67, 0x101: 45,..</code></p>\n</blockquote>\n<p>###网络字节序<br>网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。<br>Berkeley套接字定义了一组转换函数，用于<code>16bit</code>和<code>32bit</code>整数在网络序和本机字节序之间的转换。<code>htonl</code>，<code>htons</code>用于本机序转换到网络序；<code>ntohl</code>，<code>ntohs</code>用于网络序转换到本机序</p>\n<p>最近项目涉及到H264的编解码，传输的方式是采用socket其中解码的时候需要根据服务器传输的数据流的头部获取一些数据，比如屏幕宽、高、屏幕分辨率等，简单的说结构如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> Header &#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> width;     <span class=\"comment\">//宽</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> height;    <span class=\"comment\">//高</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> pixel;         <span class=\"comment\">//分辨率</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里会出现什么问题呢？</p>\n<ol>\n<li>网络字节序是采用<code>大端序</code>，简单的说就是把数据的高位存在低地址下。</li>\n<li>数据流的的格式如下<code>&lt;Header&gt;&lt;NALU&gt;</code>,所以我第一是要知道<code>Header</code>的长度，如果直接用<code>sizeof(Header)</code>获取产长度的话，获取的长度可能以为平台的不同而有出入，根本原因是因为<code>内存对齐</code>规则，这个我会在下一篇文章分享。</li>\n</ol>\n<p>###大端序和小端序（big-endian vs little-endian）<br>其实大端序可以理解从左往右读取，小端序是从右往左读取。为了解释方便我们就用0x0A0B0C0D作为对象并且数据大小以8bit为单位。</p>\n<ul>\n<li><strong><em>大端序 (big-endian)</em></strong><br><br>地址增长方向 → <br></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>…</th>\n<th>0A</th>\n<th>0B</th>\n<th>0C</th>\n<th>0D</th>\n<th>…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>示例中，最高位字节<code>0x0A</code> 存储在最低的内存地址处。下一个字节<code>0x0B</code>存在后面的地址处。正类似于十六进制字节<code>从左到右</code>的阅读顺序</p>\n<ul>\n<li><strong><em>小端序 (little-endian)</em></strong> <br><br>地址增长方向 → <br></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>…</th>\n<th>0D</th>\n<th>0C</th>\n<th>0B</th>\n<th>0A</th>\n<th>…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>最低位字节是<code>0x0D</code> 存储在最低的内存地址处。后面字节依次存在后面的地址处。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"字节序\"><a href=\"#字节序\" class=\"headerlink\" title=\"字节序\"></a>字节序</h1><blockquote>\n<p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为<code>int</code>的变量<code>x</code>地址为<code>0x100</code>，那么其对应地址表达式<code>&amp;x</code>的值为<code>0x100</code>。且<code>x</code>的四个字节将被存储在存储器的<code>0x100</code>, <code>0x101</code>, <code>0x102</code>, <code>0x103</code>位置。<br>而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。<br>例如假设上述变量<code>x</code>类型为<code>int</code>，位于地址<code>0x100</code>处，它的十六进制为<code>0x01234567</code>，地址范围为<code>0x100~0x103</code>字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：<code>0x100: 01, 0x101: 23,..</code>。而小端法将是：<code>0x100: 67, 0x101: 45,..</code></p>\n</blockquote>\n<p>###网络字节序<br>网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。<br>Berkeley套接字定义了一组转换函数，用于<code>16bit</code>和<code>32bit</code>整数在网络序和本机字节序之间的转换。<code>htonl</code>，<code>htons</code>用于本机序转换到网络序；<code>ntohl</code>，<code>ntohs</code>用于网络序转换到本机序</p>\n<p>最近项目涉及到H264的编解码，传输的方式是采用socket其中解码的时候需要根据服务器传输的数据流的头部获取一些数据，比如屏幕宽、高、屏幕分辨率等，简单的说结构如下:</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> Header &#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> width;     <span class=\"comment\">//宽</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> height;    <span class=\"comment\">//高</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> pixel;         <span class=\"comment\">//分辨率</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里会出现什么问题呢？</p>\n<ol>\n<li>网络字节序是采用<code>大端序</code>，简单的说就是把数据的高位存在低地址下。</li>\n<li>数据流的的格式如下<code>&lt;Header&gt;&lt;NALU&gt;</code>,所以我第一是要知道<code>Header</code>的长度，如果直接用<code>sizeof(Header)</code>获取产长度的话，获取的长度可能以为平台的不同而有出入，根本原因是因为<code>内存对齐</code>规则，这个我会在下一篇文章分享。</li>\n</ol>\n<p>###大端序和小端序（big-endian vs little-endian）<br>其实大端序可以理解从左往右读取，小端序是从右往左读取。为了解释方便我们就用0x0A0B0C0D作为对象并且数据大小以8bit为单位。</p>\n<ul>\n<li><strong><em>大端序 (big-endian)</em></strong><br><br>地址增长方向 → <br></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>…</th>\n<th>0A</th>\n<th>0B</th>\n<th>0C</th>\n<th>0D</th>\n<th>…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>示例中，最高位字节<code>0x0A</code> 存储在最低的内存地址处。下一个字节<code>0x0B</code>存在后面的地址处。正类似于十六进制字节<code>从左到右</code>的阅读顺序</p>\n<ul>\n<li><strong><em>小端序 (little-endian)</em></strong> <br><br>地址增长方向 → <br></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>…</th>\n<th>0D</th>\n<th>0C</th>\n<th>0B</th>\n<th>0A</th>\n<th>…</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>最低位字节是<code>0x0D</code> 存储在最低的内存地址处。后面字节依次存在后面的地址处。</p>\n"}],"PostAsset":[{"_id":"source/_posts/探索iOS事件处理/3.png","slug":"3.png","post":"cjghl49fy0002pnqkkkgmk9l4","modified":0,"renderable":0},{"_id":"source/_posts/KVC探索与实践/1.jpg","slug":"1.jpg","post":"cjghl49fq0000pnqkivngw7w1","modified":0,"renderable":0},{"_id":"source/_posts/探索iOS事件处理/2.png","slug":"2.png","post":"cjghl49fy0002pnqkkkgmk9l4","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[],"Tag":[]}}