---
title: 字节序
date: 2017-03-22 17:41:56
---
# 字节序
> 在几乎所有的机器上，多字节对象都被存储为连续的字节序列。例如在C语言中，一个类型为`int`的变量`x`地址为`0x100`，那么其对应地址表达式`&x`的值为`0x100`。且`x`的四个字节将被存储在存储器的`0x100`, `0x101`, `0x102`, `0x103`位置。
而存储地址内的排列则有两个通用规则。一个多位的整数将按照其存储地址的最低或最高字节排列。如果最低有效位在最高有效位的前面，则称小端序；反之则称大端序。在网络应用中，字节序是一个必须被考虑的因素，因为不同机器类型可能采用不同标准的字节序，所以均按照网络标准转化。
例如假设上述变量`x`类型为`int`，位于地址`0x100`处，它的十六进制为`0x01234567`，地址范围为`0x100~0x103`字节，其内部排列顺序依赖于机器的类型。大端法从首位开始将是：`0x100: 01, 0x101: 23,..`。而小端法将是：`0x100: 67, 0x101: 45,..`


###网络字节序
网络传输一般采用大端序，也被称之为网络字节序，或网络序。IP协议中定义大端序为网络字节序。
Berkeley套接字定义了一组转换函数，用于`16bit`和`32bit`整数在网络序和本机字节序之间的转换。`htonl`，`htons`用于本机序转换到网络序；`ntohl`，`ntohs`用于网络序转换到本机序

最近项目涉及到H264的编解码，传输的方式是采用socket其中解码的时候需要根据服务器传输的数据流的头部获取一些数据，比如屏幕宽、高、屏幕分辨率等，简单的说结构如下:

```objc
struct Header {
    unsigned int width;     //宽
    unsigned int height;    //高
    long int pixel;         //分辨率
};
```
这里会出现什么问题呢？

1. 网络字节序是采用`大端序`，简单的说就是把数据的高位存在低地址下。
2. 数据流的的格式如下`<Header><NALU>`,所以我第一是要知道`Header`的长度，如果直接用`sizeof(Header)`获取产长度的话，获取的长度可能以为平台的不同而有出入，根本原因是因为`内存对齐`规则，这个我会在下一篇文章分享。

###大端序和小端序（big-endian vs little-endian）
其实大端序可以理解从左往右读取，小端序是从右往左读取。为了解释方便我们就用0x0A0B0C0D作为对象并且数据大小以8bit为单位。


* ***大端序 (big-endian)***<br>
地址增长方向 → <br>

| ... | 0A | 0B | 0C | 0D | ...  |
| --- | --- | --- | --- | --- | --- |
示例中，最高位字节`0x0A` 存储在最低的内存地址处。下一个字节`0x0B`存在后面的地址处。正类似于十六进制字节`从左到右`的阅读顺序

* ***小端序 (little-endian)*** <br>
  地址增长方向 → <br>
  
| ... | 0D | 0C | 0B | 0A | ... |
| --- | --- | --- | --- | --- | --- |
最低位字节是`0x0D` 存储在最低的内存地址处。后面字节依次存在后面的地址处。


